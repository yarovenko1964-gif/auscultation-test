<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>ü´Ä Cardiac Auscultation Trainer v7.0.48 ‚Äì Phone Edition</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
--primary: #1565c0;
--primary-dark: #0d47a1;
--success: #2e7d32;
--warning: #f57c00;
--danger: #c62828;
--bg-dark: #0a1929;
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
background: linear-gradient(135deg, #0d47a1 0%, #1565c0 100%);
min-height: 100vh;
padding: 6px;
}
.container {
max-width: 480px;
margin: 0 auto;
background: #fff;
border-radius: 16px;
box-shadow: 0 12px 40px rgba(0,0,0,0.3);
overflow: hidden;
}
.header {
background: linear-gradient(135deg, var(--primary-dark), var(--primary));
color: #fff;
padding: 12px;
text-align: center;
}
.header h1 { font-size: 15px; font-weight: 800; }
.header-sub { font-size: 9px; opacity: .9; margin-top: 2px; }
.badge {
display: inline-block;
background: rgba(76,175,80,.25);
border: 1px solid rgba(76,175,80,.55);
padding: 2px 8px;
border-radius: 10px;
font-size: 7px;
margin-top: 4px;
font-weight: 900;
letter-spacing: .4px;
}
.mode-tabs {
display: flex;
background: #f5f5f5;
border-bottom: 1px solid #e0e0e0;
}
.mode-tab {
flex: 1;
padding: 10px;
text-align: center;
font-size: 10px;
font-weight: 900;
cursor: pointer;
border: none;
background: transparent;
color: #666;
border-bottom: 3px solid transparent;
transition: all .2s;
user-select: none;
}
.mode-tab.active {
color: var(--primary);
background: #fff;
border-bottom-color: var(--primary);
}
.tab-icon { font-size: 14px; display: block; margin-bottom: 2px; }
.point-selector {
padding: 8px 12px;
background: #fafafa;
border-bottom: 1px solid #eee;
}
.point-selector label { font-size: 9px; color: #666; font-weight: 900; }
.point-selector select {
width: 100%;
padding: 6px 8px;
margin-top: 4px;
border: 1px solid #ddd;
border-radius: 6px;
font-size: 11px;
background: #fff;
}
.status-bar {
padding: 4px 10px;
background: var(--primary-dark);
color: #fff;
font-size: 9px;
display: flex;
justify-content: space-between;
align-items: center;
gap: 8px;
}
.status-left { display: flex; align-items: center; gap: 6px; }
.mini-pill {
display: inline-flex;
align-items: center;
gap: 4px;
padding: 2px 6px;
border-radius: 10px;
font-size: 7px;
font-weight: 900;
background: rgba(255,255,255,.12);
border: 1px solid rgba(255,255,255,.18);
}
.mini-dot {
width: 6px; height: 6px; border-radius: 50%;
background: #bbb;
box-shadow: 0 0 10px rgba(255,255,255,.2);
}
.warning-badge {
padding: 2px 6px;
border-radius: 4px;
font-size: 7px;
font-weight: 900;
display: none;
letter-spacing: .3px;
}
.warning-badge.active { display: inline-block; }
.warning-badge.voice { background: #ff9800; color: #000; }
.warning-badge.weak { background: #f44336; color: #fff; }
.warning-badge.unstable { background: #ffeb3b; color: #000; }
.progress-container {
display: none;
padding: 4px 10px;
background: #e3f2fd;
border-bottom: 1px solid #bbdefb;
}
.progress-container.show { display: block; }
.progress-bar {
height: 4px;
background: #bbdefb;
border-radius: 2px;
overflow: hidden;
}
.progress-fill {
height: 100%;
background: var(--primary);
width: 0%;
transition: width .2s;
}
.progress-text {
font-size: 9px;
color: var(--primary);
text-align: center;
margin-top: 2px;
font-weight: 900;
}
.position-mode { display: none; }
.position-mode.active { display: block; }
.position-display {
padding: 16px;
background: var(--bg-dark);
text-align: center;
}
.signal-meter {
position: relative;
width: 200px;
height: 200px;
margin: 0 auto 16px;
transition: opacity .2s;
}
.signal-meter.unstable { opacity: .55; }
.meter-bg {
position: absolute; inset: 0;
border-radius: 50%;
background: conic-gradient(from 135deg, #c62828 0deg, #f57c00 72deg, #fdd835 126deg, #8bc34a 162deg, #4caf50 198deg, #2e7d32 225deg, transparent 225deg);
opacity: .3;
}
.meter-mask {
position: absolute;
top: 15px; left: 15px; right: 15px; bottom: 15px;
border-radius: 50%;
background: var(--bg-dark);
}
.meter-needle {
position: absolute;
bottom: 50%; left: 50%;
width: 4px;
height: 70px;
background: linear-gradient(to top, #fff, transparent);
transform-origin: bottom center;
transform: translateX(-50%) rotate(-135deg);
transition: transform .18s ease-out;
border-radius: 2px;
}
.meter-value {
position: absolute;
top: 50%; left: 50%;
transform: translate(-50%, -50%);
text-align: center;
}
.signal-percent {
font-size: 52px;
font-weight: 900;
color: #fff;
line-height: 1;
text-shadow: 0 0 30px currentColor;
transition: color .2s, text-shadow .2s;
}
.signal-label {
font-size: 10px;
color: rgba(255,255,255,.6);
margin-top: 4px;
text-transform: uppercase;
letter-spacing: 1px;
font-weight: 900;
}
.snr-display {
font-size: 11px;
color: rgba(255,255,255,.5);
margin-top: 2px;
font-weight: 900;
}
.best-score {
display: flex;
justify-content: center;
gap: 20px;
margin-bottom: 12px;
flex-wrap: wrap;
}
.best-item {
text-align: center;
padding: 8px 16px;
background: rgba(255,255,255,.05);
border-radius: 8px;
min-width: 140px;
}
.best-value { font-size: 20px; font-weight: 900; color: #4caf50; }
.best-label { font-size: 8px; color: rgba(255,255,255,.5); text-transform: uppercase; font-weight: 900; }
.best-point { font-size: 9px; color: rgba(255,255,255,.75); font-weight: 900; }
.position-guide {
background: rgba(255,255,255,.08);
border-radius: 8px;
padding: 10px;
margin-bottom: 12px;
}
.guide-text {
font-size: 12px;
color: #fff;
font-weight: 900;
text-align: center;
}
.guide-hint {
font-size: 9px;
color: rgba(255,255,255,.65);
text-align: center;
margin-top: 4px;
font-weight: 900;
}
.motion-hint {
background: rgba(255,152,0,.15);
border: 1px solid rgba(255,152,0,.3);
border-radius: 8px;
padding: 8px 12px;
margin-bottom: 12px;
display: none;
text-align: center;
}
.motion-hint.active { display: block; }
.motion-hint-text {
font-size: 11px;
color: #ff9800;
font-weight: 900;
}
.contact-indicator {
background: rgba(255,255,255,.06);
border-radius: 8px;
padding: 8px 10px;
margin-bottom: 12px;
}
.contact-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 6px;
}
.contact-title {
font-size: 9px;
color: rgba(255,255,255,.6);
font-weight: 900;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.contact-level {
font-size: 10px;
font-weight: 900;
padding: 2px 8px;
border-radius: 10px;
}
.contact-level.weak { color: #f44336; background: rgba(244,67,54,.2); }
.contact-level.moderate { color: #ff9800; background: rgba(255,152,0,.2); }
.contact-level.good { color: #8bc34a; background: rgba(139,195,74,.2); }
.contact-level.excellent { color: #4caf50; background: rgba(76,175,80,.2); }
.contact-bar-wrap {
background: rgba(0,0,0,.3);
border-radius: 4px;
height: 8px;
overflow: hidden;
}
.contact-bar-fill {
height: 100%;
border-radius: 4px;
transition: width 0.2s, background 0.2s;
width: 0%;
}
.trend-container {
background: rgba(255,255,255,.06);
border-radius: 8px;
padding: 8px 10px;
margin-bottom: 12px;
}
.trend-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 6px;
}
.trend-title {
font-size: 9px;
color: rgba(255,255,255,.6);
font-weight: 900;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.trend-status {
font-size: 10px;
font-weight: 900;
padding: 2px 8px;
border-radius: 10px;
background: rgba(255,255,255,.1);
}
.trend-status.improving { color: #4caf50; background: rgba(76,175,80,.2); }
.trend-status.declining { color: #f44336; background: rgba(244,67,54,.2); }
.trend-status.stable { color: #ffc107; background: rgba(255,193,7,.2); }
.trend-canvas-wrap {
background: rgba(0,0,0,.3);
border-radius: 6px;
overflow: hidden;
height: 44px;
}
#trendCanvas {
display: block;
width: 100%;
height: 44px;
}
.comparison-section {
padding: 12px;
background: #f8f9fa;
}
.comparison-title {
font-size: 10px;
font-weight: 900;
color: #333;
margin-bottom: 8px;
}
.comparison-bars { display: flex; flex-direction: column; gap: 6px; }
.comp-bar { display: flex; align-items: center; gap: 8px; }
.comp-label { width: 70px; font-size: 9px; color: #666; font-weight: 900; }
.comp-track {
flex: 1;
height: 18px;
background: #e0e0e0;
border-radius: 9px;
overflow: hidden;
position: relative;
}
.comp-fill {
height: 100%;
border-radius: 9px;
transition: width .2s, background .2s;
display: flex;
align-items: center;
justify-content: flex-end;
padding-right: 6px;
min-width: 0;
}
.comp-value {
font-size: 9px;
font-weight: 900;
color: #fff;
text-shadow: 0 1px 2px rgba(0,0,0,.4);
}
.ring-mode { display: none; }
.ring-mode.active { display: block; }
.ring-section {
padding: 16px;
background: linear-gradient(135deg, #1a237e 0%, #0d47a1 100%);
margin: 8px 12px;
border-radius: 12px;
}
.ring-container {
width: 220px;
height: 220px;
margin: 0 auto;
position: relative;
}
.ring-base {
position: absolute;
inset: 0;
border-radius: 50%;
background: rgba(255,255,255,0.05);
border: 2px solid rgba(255,255,255,0.15);
}
.ring-segment {
position: absolute;
inset: 0;
border-radius: 50%;
transform-origin: center;
transition: opacity 0.3s;
}
.ring-label {
position: absolute;
font-size: 9px;
font-weight: 900;
color: #fff;
transform: translate(-50%, -50%);
text-align: center;
line-height: 1.2;
text-shadow: 0 1px 3px rgba(0,0,0,0.5);
white-space: pre-line;
}
.ring-center {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0,0,0,0.5);
width: 70px;
height: 70px;
border-radius: 50%;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
border: 2px solid rgba(255,255,255,0.2);
}
.ring-center-value {
font-size: 18px;
font-weight: 900;
color: #4caf50;
transition: color 0.3s;
}
.ring-center-label {
font-size: 7px;
color: rgba(255,255,255,0.7);
text-transform: uppercase;
font-weight: 900;
}
.ring-legend {
display: flex;
justify-content: center;
flex-wrap: wrap;
gap: 10px;
margin-top: 12px;
}
.ring-legend-item {
display: flex;
align-items: center;
gap: 4px;
font-size: 8px;
color: rgba(255,255,255,0.85);
font-weight: 900;
}
.ring-legend-dot {
width: 12px;
height: 12px;
border-radius: 3px;
}
.ring-bars {
margin-top: 12px;
padding-top: 12px;
border-top: 1px solid rgba(255,255,255,0.1);
}
.ring-bars .comparison-title {
color: rgba(255,255,255,0.8);
margin-bottom: 8px;
}
.ring-bars .comp-label {
color: rgba(255,255,255,0.7);
}
.ring-bars .comp-track {
background: rgba(255,255,255,0.15);
}
.visual-mode { display: none; }
.visual-mode.active { display: block; }
.visual-disclaimer {
background: #fff3e0;
padding: 6px 10px;
font-size: 8px;
color: #e65100;
text-align: center;
border-bottom: 1px solid #ffe0b2;
font-weight: 900;
}
.waveform-container {
height: 180px;
background: var(--bg-dark);
position: relative;
overflow: hidden;
}
.waveform-canvas {
width: 100%;
height: 100%;
position: absolute;
inset: 0;
}
.wave-overlay {
position: absolute;
font-size: 10px;
padding: 3px 6px;
background: rgba(0,0,0,.6);
border-radius: 4px;
font-weight: 900;
}
.wave-overlay.top-left { top: 6px; left: 6px; color: #4caf50; }
.wave-overlay.top-right { top: 6px; right: 6px; color: #fff; }
.wave-overlay.bottom-left { bottom: 6px; left: 6px; color: #2196f3; }
.hr-display { font-size: 12px; }
.hr-value { font-size: 22px; font-weight: 900; }
.visual-metrics {
display: flex;
justify-content: space-around;
padding: 10px;
background: #f5f5f5;
border-top: 1px solid #e0e0e0;
}
.v-metric { text-align: center; }
.v-metric-label { font-size: 8px; color: #888; text-transform: uppercase; font-weight: 900; }
.v-metric-value { font-size: 14px; font-weight: 900; color: #333; }
.visual-legend {
display: flex;
justify-content: center;
gap: 12px;
padding: 6px;
background: #fafafa;
border-top: 1px solid #eee;
}
.legend-item { display: flex; align-items: center; gap: 4px; font-size: 8px; color: #666; font-weight: 900; }
.legend-dot { width: 10px; height: 10px; border-radius: 2px; }
.controls {
display: flex;
flex-wrap: wrap;
gap: 6px;
padding: 12px;
background: #f5f5f5;
border-top: 1px solid #e0e0e0;
}
.btn {
flex: 1 1 calc(33% - 6px);
min-width: 80px;
padding: 10px;
border: none;
border-radius: 8px;
font-size: 11px;
font-weight: 900;
cursor: pointer;
transition: transform .1s, box-shadow .1s;
text-transform: uppercase;
user-select: none;
touch-action: manipulation;
}
.btn:active { transform: scale(0.96); }
.btn-start {
background: linear-gradient(135deg, #4caf50, #2e7d32);
color: #fff;
flex: 1 1 100%;
}
.btn-stop {
background: linear-gradient(135deg, #f44336, #c62828);
color: #fff;
flex: 1 1 100%;
display: none;
}
.btn-reset { background: #ff9800; color: #fff; }
.btn-ring { background: #9c27b0; color: #fff; }
.btn-export { background: #607d8b; color: #fff; }
.btn-recal { background: #00bcd4; color: #fff; display: none; }
</style>
</head>
<body>
<div class="container">
<div class="header">
<h1>ü´Ä Cardiac Auscultation Trainer</h1>
<p class="header-sub">Optimal Phone Mic Positioning</p>
<span class="badge">v7.0.48 ‚Äî NO_CONTACT noise learn + soft motion CAL</span>
</div>
<div class="mode-tabs">
<button class="mode-tab active" id="tabPosition"><span class="tab-icon">üéØ</span>Position</button>
<button class="mode-tab" id="tabRing"><span class="tab-icon">‚≠ï</span>Ring</button>
<button class="mode-tab" id="tabVisual"><span class="tab-icon">üìä</span>Visual</button>
</div>
<div class="point-selector">
<label>AUSCULTATION POINT</label>
<select id="pointSelect">
<option value="aortic">Aortic (2nd R ICS)</option>
<option value="pulmonary">Pulmonary (2nd L ICS)</option>
<option value="tricuspid">Tricuspid (4th L ICS)</option>
<option value="mitral" selected>Mitral Apex (5th L MCL)</option>
<option value="erb">Erb's Point (3rd L ICS)</option>
</select>
</div>
<div class="status-bar">
<div class="status-left">
<span id="statusText">‚ö™ Ready</span>
<div class="mini-pill">
<div class="mini-dot" id="stabilityDot"></div>
<span id="stabilityText">--</span>
</div>
</div>
<div>
<span class="warning-badge voice" id="voiceBadge">VOICE</span>
<span class="warning-badge weak" id="weakBadge">WEAK</span>
<span class="warning-badge unstable" id="unstableBadge">MOVE</span>
</div>
</div>
<div class="progress-container" id="progressContainer">
<div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
<p class="progress-text" id="progressText">Calibrating baseline...</p>
</div>
<div class="position-mode active" id="positionMode">
<div class="position-display">
<div class="signal-meter" id="signalMeter">
<div class="meter-bg"></div>
<div class="meter-mask"></div>
<div class="meter-needle" id="meterNeedle"></div>
<div class="meter-value">
<div class="signal-percent" id="signalPercent">--</div>
<div class="signal-label">SIGNAL QUALITY</div>
<div class="snr-display" id="snrDisplay">SNR -- dB</div>
</div>
</div>
<div class="best-score">
<div class="best-item">
<div class="best-value" id="bestSession">--</div>
<div class="best-label">Best Session</div>
<div class="best-point" id="bestPoint">--</div>
</div>
<div class="best-item">
<div class="best-value" id="currentPointBest">--</div>
<div class="best-label">Best at Point</div>
<div class="best-point" id="currentPointLabel">Mitral</div>
</div>
</div>
<div class="position-guide">
<p class="guide-text" id="guideText">Press START to begin</p>
<p class="guide-hint" id="guideHint">Move device slowly to find strongest signal</p>
</div>
<div class="motion-hint" id="motionHint">
<span class="motion-hint-text" id="motionHintText">ü§≤ Hold steady</span>
</div>
<div class="contact-indicator" id="contactIndicator">
<div class="contact-header">
<span class="contact-title">Body Contact</span>
<span class="contact-level" id="contactLevel">--</span>
</div>
<div class="contact-bar-wrap"><div class="contact-bar-fill" id="contactBarFill"></div></div>
</div>
<div class="trend-container" id="trendContainer">
<div class="trend-header">
<span class="trend-title">Signal Trend (last 10s)</span>
<span class="trend-status" id="trendStatus">--</span>
</div>
<div class="trend-canvas-wrap"><canvas id="trendCanvas" width="280" height="44"></canvas></div>
</div>
</div>
<div class="comparison-section">
<h3 class="comparison-title">üìä Compare All Points</h3>
<div class="comparison-bars">
<div class="comp-bar"><div class="comp-label">Aortic</div><div class="comp-track"><div class="comp-fill" id="aorticBar"></div></div></div>
<div class="comp-bar"><div class="comp-label">Pulmonary</div><div class="comp-track"><div class="comp-fill" id="pulmonaryBar"></div></div></div>
<div class="comp-bar"><div class="comp-label">Tricuspid</div><div class="comp-track"><div class="comp-fill" id="tricuspidBar"></div></div></div>
<div class="comp-bar"><div class="comp-label">Mitral</div><div class="comp-track"><div class="comp-fill" id="mitralBar"></div></div></div>
<div class="comp-bar"><div class="comp-label">Erb's</div><div class="comp-track"><div class="comp-fill" id="erbBar"></div></div></div>
</div>
</div>
</div>
<div class="ring-mode" id="ringMode">
<div class="ring-section">
<div class="ring-container" id="ringContainer">
<div class="ring-base"></div>
<div class="ring-center">
<div class="ring-center-value" id="ringCenterValue">--</div>
<div class="ring-center-label">Best</div>
</div>
</div>
<div class="ring-legend">
<div class="ring-legend-item"><div class="ring-legend-dot" style="background:#4caf50;"></div><span>>70% Excellent</span></div>
<div class="ring-legend-item"><div class="ring-legend-dot" style="background:#8bc34a;"></div><span>50-70% Good</span></div>
<div class="ring-legend-item"><div class="ring-legend-dot" style="background:#ffc107;"></div><span>30-50% Fair</span></div>
<div class="ring-legend-item"><div class="ring-legend-dot" style="background:#f44336;"></div><span><30% Weak</span></div>
</div>
<div class="ring-bars">
<h3 class="comparison-title">All Points</h3>
<div class="comparison-bars">
<div class="comp-bar"><div class="comp-label">Aortic</div><div class="comp-track"><div class="comp-fill" id="aorticBarRing"></div></div></div>
<div class="comp-bar"><div class="comp-label">Pulmonary</div><div class="comp-track"><div class="comp-fill" id="pulmonaryBarRing"></div></div></div>
<div class="comp-bar"><div class="comp-label">Tricuspid</div><div class="comp-track"><div class="comp-fill" id="tricuspidBarRing"></div></div></div>
<div class="comp-bar"><div class="comp-label">Mitral</div><div class="comp-track"><div class="comp-fill" id="mitralBarRing"></div></div></div>
<div class="comp-bar"><div class="comp-label">Erb's</div><div class="comp-track"><div class="comp-fill" id="erbBarRing"></div></div></div>
</div>
</div>
</div>
</div>
<div class="visual-mode" id="visualMode">
<div class="visual-disclaimer">‚ö†Ô∏è Educational visualization only ‚Äî not for diagnosis</div>
<div class="waveform-container">
<canvas id="waveformCanvas" class="waveform-canvas"></canvas>
<canvas id="spectrogramCanvas" class="waveform-canvas"></canvas>
<div class="wave-overlay top-left" id="phaseLabel">Phase: --</div>
<div class="wave-overlay top-right hr-display"><span class="hr-value" id="hrValue">--</span> bpm</div>
<div class="wave-overlay bottom-left" id="pointLabel">Mitral</div>
</div>
<div class="visual-metrics">
<div class="v-metric"><div class="v-metric-label">S1</div><div class="v-metric-value" id="s1Value">--</div></div>
<div class="v-metric"><div class="v-metric-label">S2</div><div class="v-metric-value" id="s2Value">--</div></div>
<div class="v-metric"><div class="v-metric-label">SNR</div><div class="v-metric-value" id="snrMetric">--</div></div>
<div class="v-metric"><div class="v-metric-label">Murmur</div><div class="v-metric-value" id="murmurValue">--</div></div>
</div>
<div class="visual-legend">
<div class="legend-item"><div class="legend-dot" style="background:#2196f3;"></div>Waveform</div>
<div class="legend-item"><div class="legend-dot" style="background:#f44336;"></div>Envelope</div>
<div class="legend-item"><div class="legend-dot" style="background:#4caf50;"></div>Peaks</div>
<div class="legend-item"><div class="legend-dot" style="background:#ff9800;"></div>Spectrogram</div>
</div>
</div>
<div class="controls">
<button class="btn btn-start" id="startBtn">‚ñ∂ START</button>
<button class="btn btn-stop" id="stopBtn">‚èπ STOP</button>
<button class="btn btn-reset" id="resetBtn">‚Ü∫ Reset</button>
<button class="btn btn-ring" id="ringBtn">‚≠ï Ring</button>
<button class="btn btn-export" id="exportBtn">üì• Export</button>
<button class="btn btn-recal" id="recalBtn">üîß Recal</button>
</div>
</div>
<script>
'use strict';
/**
* Cardiac Auscultation Trainer v7.0.6
*
* CHANGELOG v7.0.6 (February 2026):
* PERFORMANCE OPTIMIZATION ‚Äî UI update frequency optimized
*  1. UI.UPDATE_MS: 100 ms (10 FPS) ‚Äî optimal for educational feedback
*     Reason: Training app doesn't need 30 FPS, 10 FPS is sufficient for educational feedback
*     Benefit: Better battery life, especially on low-end devices
*  2. NEEDLE_SMOOTH: 0.18 ‚Üí 0.35 (increased smoothing for smoother needle at lower update rate)
*     Result: Needle appears smooth despite fewer updates
*
* CHANGELOG v7.0.3 (February 2026):
* HARDCODE FIXES ‚Äî Refactored hardcodes to CONFIG
*  1. Replaced calMean < 0.1 with CONFIG.CALIBRATION.MIN_BASELINE_ENERGY (value: 0.1)
*  2. Replaced calContactMin = 25 with CONFIG.CALIBRATION.CONTACT_MIN (updated from 35 to 25 in CONFIG)
*  3. Added CONFIG.CONTACT.LIVE_MIN: 40 for LIVE contactLevel check
*  4. Fixed export filename to v7_0_3.json (sed bug in previous)
*
* CHANGELOG v7.0.2 (February 2026):
* CALIBRATION FIX ‚Äî unblocking state machine
*  1. Fault-tolerant calibration: allow up to 5 bad frames (was: 1 bad = full reset)
*  2. Contact threshold for WAITING/CALIBRATION: 25 (was: 40, too strict for table/weak contact)
*  3. MIN_BASELINE_ENERGY: 0.1 (was: 0.5, blocked calibration on real device)
*  4. Diagnostic status bar: shows C:XX H:XX% values in real-time
*  5. Shows which condition fails during calibration dropout
*
* CHANGELOG v7.0.2 (February 2026):
* HARDENING ‚Äî Cross-audit fixes
*  1. NOISE.FLOOR_MIN 0.5‚Üí0.05 (was cutting real cardiac signal)
*  2. CircularBuffer for envelope (zero-alloc, no push/shift/slice)
*  3. beforeunload handler (release mic on tab close)
*  4. DeviceMotion requestPermission before getUserMedia (iOS gesture chain)
*  5. hzToBin guard when sampleRate=0
*
* CHANGELOG v7.0.0 (February 2026):
* FULL AUDIT & FIX ‚Äî based on static analysis of v6.9.8
*
* CRITICAL FIXES:
*  1. Removed duplicate CONFIG tail (lines 903-908 SyntaxError)
*  2. Removed duplicate DOM update block in updateContactIndicator()
*  3. Unified ALL CONFIG references to nested format (CONFIG.DSP.*, CONFIG.FREQ.*, etc.)
*  4. Fixed undefined globals: STABLE_WINDOW_MS ‚Üí CONFIG.CALIBRATION.STABLE_WINDOW_MS
*     RECAL_SILENCE_MS ‚Üí CONFIG.SILENCE.DURATION_MAX_MS
*     RECAL_MOTION_MS ‚Üí CONFIG.RECALIBRATION.MOTION_TIMEOUT_MS
*  5. Fixed onMotion() guard: removed isCalibrated check so motion data
*     is collected during WAITING/CALIBRATION states
*  6. Fixed recalibration motion logic (was unreachable)
*  7. Fixed silenceDurationMs using real delta-time instead of assumed 100ms
*
* PHYSIOLOGICAL PIPELINE:
*  8. Added baseline sanity-check (reject calibration if mean energy too low)
*  9. Added contact hysteresis for LIVE‚ÜíWAITING transition (debounce 500ms)
* 10. HR sanity-check with exponential moving average (reject >20% jumps)
*
* PERFORMANCE:
* 11. Cached Hz-lookup array (eliminates binToHz() in hot loops)
* 12. Reduced drawTrendGraph to 3Hz instead of 10Hz
* 13. updateComparisonBars only on bestByPoint change
* 14. Replaced WorkletProcessor spread-push with typed array copy
* 15. Replaced Math.max(...arr) spread with loop
*/
// ============================================================================
// CONFIGURATION ‚Äî Single Source of Truth (nested)
// ============================================================================
const CONFIG = {
DSP: {
FFT_SIZE: 4096,
BUFFER_SIZE: 2048,
SAMPLE_RATE_IDEAL: 44100
},
FREQ: {
HEART_LOW: 20,
HEART_HIGH: 220,
VOICE_LOW: 300,
VOICE_HIGH: 3000,
CONTACT_LOW: 20,
CONTACT_HIGH: 100,
HIGH_FREQ_GATE: 1000
},
MEMS: {
CUTOFF: 100,
MAX_BOOST: 8
},
QUALITY: {
SMOOTH_FACTOR: 0.06,
WEAK_THRESHOLD: 22,
SNR_FLOOR: -10,
SNR_CEILING: 18,
VOICE_PENALTY_MIN: 0.15,
VOICE_DOMINANT_FRAMES: 8,
HDR_PENALTY_MIN: 0.2,
HDR_LOW_FRAMES: 10
},
CALIBRATION: {
FRAMES_REQUIRED: 40,
REQUIRED_WEIGHT: 40,
MIN_CLEAN_FRAMES: 12,
MIN_HOLD_MS: 1500,
BAD_DEBOUNCE_MS: 1000,
CONTACT_MIN: 25,
CONTACT_MIN_START: 35,
NO_CONTACT_LEARN_MAX: 4,
NO_CONTACT_LEARN_MS: 2500,
NO_CONTACT_RECENT_MS: 5000,
CONTACT_WINDOW_MS: 900,
STABLE_WINDOW_MS: 1000,
WAIT_STABLE_MS: 1200,
WAITING_TIMEOUT_MS: 12000,
MIN_BASELINE_ENERGY: 5.0,
HEART_START_MIN: 0.9,
TIMEOUT_MS: 15000,
VOICE_BLOCK_FRAMES: 8,
HDR_BLOCK_FRAMES: 8,
HEART_CONSISTENCY_FACTOR: 0.6,
PERIODICITY_MIN: 0.10
},
VOICE: {
RATIO_THRESHOLD: 1.8,
HOLD_MS: 1500,
HDR_MIN_LIVE: 0.25,
HDR_MIN_WAIT_HINT: 0.15
},
MOTION: {
THRESHOLD: 0.12,
THRESHOLD_WAIT: 0.22,
WAIT_DEBOUNCE_MS: 1300,
SMOOTH_ALPHA: 0.85,
SMOOTH_BETA: 0.15,
FREEZE_MS: 500,
SHAKE_RMS_TH: 0.15,
ACCEL_BUFFER_MAX: 20
},
TILT: {
ANGLE_MAX: 20
},
HR: {
MIN: 50,
MAX: 150,
MIN_BEATS: 8,
CV_MAX: 0.10,
AUTOCORR_MIN: 0.3,
SYSTOLE_FRACTION: 0.35,
ENV_MAX_SAMPLES: 240,
MAX_JUMP_RATIO: 0.20,
GATE_CONTACT_MS: 1800,
GATE_MOTION_MS: 1000,
GATE_SIGNAL_MS: 1600,
PERIODICITY_WINDOW_SAMPLES: 80
},
SILENCE: {
RMS_THRESHOLD: 0.025,
HF_THRESHOLD: 5,
DURATION_MAX_MS: 3000,
DEBOUNCE_MS: 400,
PEAK_TO_RMS_MAX: 3.2
},
CONTACT: {
SMOOTH_FACTOR: 0.15,
LOST_DEBOUNCE_MS: 500,
LIVE_MIN: 40,
MIN_TOTAL_ENERGY: 2.0,
BASE_ALPHA: 0.995,
BODY_EXCESS_GAIN: 260,
FALSE_GREEN_MAX: 12,
ENTER_TH: 0.50,
EXIT_TH: 0.40,
ENTER_MS: 600,
EXIT_MS: 400,
AIR_RATIO_CLAMP: 2.3,
LF_MECH_MIN: 6,
AIR_CLAMP_MAX: 20,
UI_WEAK_CAP: 20
},
ARTIFACT: {
PEAK_TO_RMS_TH: 6.0,
PEAK_TO_RMS_SEVERE_TH: 10.0,
CLIP_TH: 0.98,
CLIP_COUNT_TH: 8,
CLIP_COUNT_SEVERE_TH: 24,
FREEZE_MS: 800,
CONTACT_HOLD_MS: 0,
CAL_BLOCK_MS: 2200,
TRANSITION_FREEZE_MS: 500,
LF_DELTA_TH: 18
},
NOISE: {
ALPHA: 0.95,
FLOOR_MIN: 0.05,
SUBTRACTION_GAIN: 1.2,
RESIDUAL_FLOOR: 0.15,
PROTECT_LOW_HZ: 30,
PROTECT_MID_HZ: 200,
AGGRESSIVE_HZ: 300
},
UI: {
UPDATE_MS: 100,  // v7.0.6: OPTIMIZED ‚Äî 10 FPS (100ms) for educational app
NEEDLE_SMOOTH: 0.35,  // v7.0.6: Increased from 0.18 for smoother needle
HINT_HYSTERESIS_MS: 500,
RESIZE_DEBOUNCE_MS: 200,
TREND_DRAW_INTERVAL_MS: 333
},
TREND: {
HISTORY_SIZE: 100,
ANALYSIS_WINDOW: 30,
SLOPE_THRESHOLD: 0.25,
CANVAS_WIDTH: 280,
CANVAS_HEIGHT: 44
},
RECALIBRATION: {
MOTION_TIMEOUT_MS: 2000,
DEBOUNCE_MS: 500
}
};
const POINTS = {
aortic:    { name: 'Aortic',      angle: 0 },
pulmonary: { name: 'Pulmonary',   angle: 72 },
tricuspid: { name: 'Tricuspid',   angle: 144 },
mitral:    { name: 'Mitral Apex', angle: 216 },
erb:       { name: "Erb's Point", angle: 288 }
};
const POINT_ORDER = ['aortic', 'pulmonary', 'tricuspid', 'mitral', 'erb'];
// ============================================================================
// STATE ‚Äî All mutable application state
// ============================================================================
let audioCtx = null, mic = null, analyser = null, stream = null, workletNode = null, zeroGain = null;
let sampleRate = 0, isRunning = false, isCalibrated = false;
let currentMode = 'position', currentPoint = 'mitral';
let calFrames = [];
let contactCalFrames = [];
let baseline = { mean: 0, std: 1 }, noiseFloor = null;
let signalStrength = 0, currentSNR = 0, currentNeedleAngle = -135;
let rr = [], heartRate = 0, hrConfirmed = false;
let lastPeakMs = 0, lastBeatMs = 0, beatPhase = 0, lastVoiceAt = 0;
let bestSession = { score: 0, point: '' }, bestByPoint = {};
let qualityHistory = [], trendDirection = 'stable';
let contactLevel = 0, contactSmooth = 0;
let currentContactRaw = 0;
let rawContactScore = 0;
let contactForGate = 0;
let confirmedContact = false;
let contactEnterSince = 0;
let contactExitSince = 0;
let lastConfirmedContactAt = 0;
let lfMechanical = 0;
let hfAirborne = 0;
let contactAirRatio = 0;
const motion = { smoothAccel: 0, baseTotal: null, accelBuffer: [], isShaking: false, isTilted: false, currentHint: null };
const orient = { baseline: null, currentBeta: 0, currentGamma: 0 };
const stability = { isStable: true, isSoftStable: true };
let dom = {};
let reusableFftData = null;
let reusableTimeDomain = null;
let reusableDenoiseBuffer = null;
let lastTimeDomain = null;
let cachedBinHz = null;
let lastUIUpdate = 0;
let lastTrendDraw = 0;
let resizeTimer = null;
let isSilent = false;
let lastMotionAt = 0;
let motionFrozen = false;
let lastProcessTime = 0;
let lastHintShown = null;
let hintChangeAt = 0;
let appState = 'NO_CONTACT';
let stateEnteredAt = 0;
let gateReason = 'init';
let waitingConditionsMet = 0;
let lastGoodContactAt = 0;
let silenceDurationMs = 0;
let contactLostAt = 0;
let continuousMotionStart = 0;
let calBadFrames = 0;
let calBadSince = 0;
let calSoftBadSince = 0;
let heartEnergy = 0;
let voiceEnergy = 0;
let bestByPointDirty = false;
let voiceDominantFrames = 0;
let lowHdrFrames = 0;
let waitVoiceDominantFrames = 0;
let waitLowHdrFrames = 0;
let lastHDR = 0;
let silenceStartAt = 0;
let motionStartAt = 0;
let calStartAt = 0;
let lastSignalRMS = 0;
let lastHfEnergy = 0;
let artifactBurstUntil = 0;
let periodicityScore = 0;
let bestLagBpm = 0;
let hrGateReason = 'init';
let contactStableSince = 0;
let motionStableSince = 0;
let signalStableSince = 0;
let lastArtifactAt = 0;
let severeArtifactAt = 0;
let transitionFreezeUntil = 0;
let envelopeDtEmaMs = CONFIG.UI.UPDATE_MS;
let waitPeriodicityScore = 0;
let lastLfBandEnergy = 0;
let contactArtifactHoldUntil = 0;
let lastDiagLogAt = 0;
let contactBaseBody = 0;
let contactBaseNoise = 0;
let contactBaseCount = 0;
let waitMotionBadSince = 0;
let waitContactGoodSince = 0;
let waitingStartAt = 0;
let waitNoContactSince = 0;
let calWeightSum = 0;
let calCleanFrames = 0;
let waitFailCounts = {
NO_CONTACT: 0,
LOW_HEART: 0,
MOTION: 0,
TILT: 0,
ARTIFACT: 0,
HEART_INCONSISTENT: 0,
NO_PERIODICITY: 0,
WAITING: 0
};
// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
const Utils = {
nowMs: () => performance.now(),
clamp: (v, lo, hi) => Math.max(lo, Math.min(hi, v)),
mean: (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0,
std: (arr) => {
if (!arr.length) return 1;
const m = Utils.mean(arr);
return Math.sqrt(arr.reduce((s, x) => s + (x - m) ** 2, 0) / arr.length) || 1;
},
rms: (arr) => Math.sqrt(arr.reduce((s, x) => s + x * x, 0) / arr.length) || 0,
qualityColor: (score) => {
if (score >= 70) return '#4caf50';
if (score >= 50) return '#8bc34a';
if (score >= 30) return '#ffc107';
return '#f44336';
},
binToHz: (bin) => cachedBinHz ? cachedBinHz[bin] || 0 : (bin * sampleRate / CONFIG.DSP.FFT_SIZE),
hzToBin: (hz) => sampleRate > 0 ? Math.round(hz * CONFIG.DSP.FFT_SIZE / sampleRate) : 0,
memsBoost: (hz) => {
if (hz >= CONFIG.MEMS.CUTOFF) return 1;
const ratio = hz / CONFIG.MEMS.CUTOFF;
return 1 + (CONFIG.MEMS.MAX_BOOST - 1) * (1 - ratio);
},
arrayMax: (arr) => {
let max = -Infinity;
for (let i = 0; i < arr.length; i++) {
if (arr[i] > max) max = arr[i];
}
return max;
}
};
const { nowMs, clamp, mean, std, rms, qualityColor, binToHz, hzToBin, memsBoost } = Utils;
class CircularBuffer {
constructor(maxSize) {
this.data = new Float32Array(maxSize);
this.maxSize = maxSize;
this.head = 0;
this.count = 0;
}
push(val) {
this.data[this.head] = val;
this.head = (this.head + 1) % this.maxSize;
if (this.count < this.maxSize) this.count++;
}
get length() { return this.count; }
at(i) {
if (i < 0 || i >= this.count) return 0;
const idx = (this.head - this.count + i + this.maxSize) % this.maxSize;
return this.data[idx];
}
last(n) {
const len = Math.min(n, this.count);
const result = new Array(len);
for (let i = 0; i < len; i++) {
result[i] = this.at(this.count - len + i);
}
return result;
}
toArray() { return this.last(this.count); }
clear() { this.head = 0; this.count = 0; }
}
let envelope = new CircularBuffer(CONFIG.HR.ENV_MAX_SAMPLES);
let preCalSeries = new CircularBuffer(120);
function buildBinHzCache() {
const binCount = CONFIG.DSP.FFT_SIZE / 2;
cachedBinHz = new Float32Array(binCount);
for (let i = 0; i < binCount; i++) {
cachedBinHz[i] = i * sampleRate / CONFIG.DSP.FFT_SIZE;
}
}
// ============================================================================
// NOISE REDUCTION
// ============================================================================
function initDenoiser(fftLen) {
noiseFloor = new Float32Array(fftLen).fill(CONFIG.NOISE.FLOOR_MIN);
}
function resetDenoiser() {
if (noiseFloor) noiseFloor.fill(CONFIG.NOISE.FLOOR_MIN);
}
function updateNoiseFloor(spectrum, alphaOverride) {
if (!noiseFloor) initDenoiser(spectrum.length);
const { ALPHA, FLOOR_MIN } = CONFIG.NOISE;
const alpha = (typeof alphaOverride === 'number') ? clamp(alphaOverride, 0.9, 0.9995) : ALPHA;
const oneMinusAlpha = 1 - alpha;
for (let i = 0, len = spectrum.length; i < len; i++) {
const val = spectrum[i] / 255;
noiseFloor[i] = alpha * noiseFloor[i] + oneMinusAlpha * val;
if (noiseFloor[i] < FLOOR_MIN) noiseFloor[i] = FLOOR_MIN;
}
}
function subtractNoise(spectrum) {
if (!reusableDenoiseBuffer || reusableDenoiseBuffer.length !== spectrum.length) {
reusableDenoiseBuffer = new Float32Array(spectrum.length);
}
const { SUBTRACTION_GAIN, RESIDUAL_FLOOR, PROTECT_LOW_HZ, PROTECT_MID_HZ, AGGRESSIVE_HZ } = CONFIG.NOISE;
const floorMin = CONFIG.NOISE.FLOOR_MIN;
for (let i = 0, len = spectrum.length; i < len; i++) {
const val = spectrum[i] / 255;
const noise = noiseFloor ? noiseFloor[i] : floorMin;
const hz = cachedBinHz ? cachedBinHz[i] : (i * sampleRate / CONFIG.DSP.FFT_SIZE);
let factor = SUBTRACTION_GAIN;
if (hz < PROTECT_LOW_HZ) {
factor *= 0.3;
} else if (hz < PROTECT_MID_HZ) {
factor *= 0.6;
} else if (hz > AGGRESSIVE_HZ) {
factor *= 1.5;
}
reusableDenoiseBuffer[i] = Math.max(val - noise * factor, RESIDUAL_FLOOR * val);
}
return reusableDenoiseBuffer;
}
function bandEnergy(fftData, hzLo, hzHi) {
if (!sampleRate) return 0;
const lo = hzToBin(hzLo);
const hi = hzToBin(hzHi);
let e = 0, c = 0;
for (let i = lo; i <= hi && i < fftData.length; i++) {
e += fftData[i];
c++;
}
return c > 0 ? (e / c) : 0;
}
// ============================================================================
// CONTACT DETECTION
// ============================================================================
function analyzeContact(fftData) {
if (!sampleRate) return 0;
const bodyBand = bandEnergy(fftData, 80, 220);
const lowBand = bandEnergy(fftData, 20, 70);
const noiseBand = bandEnergy(fftData, 350, 1200);
const voiceBand = bandEnergy(fftData, 300, 3000);
const totalEnergy = bodyBand + lowBand + noiseBand;
if (totalEnergy < CONFIG.CONTACT.MIN_TOTAL_ENERGY) return 0;
if ((appState === 'WAITING' || appState === 'NO_CONTACT') && contactForGate < 10) {
const a = CONFIG.CONTACT.BASE_ALPHA;
if (contactBaseCount === 0) {
contactBaseBody = bodyBand;
contactBaseNoise = noiseBand + 0.5 * voiceBand;
} else {
contactBaseBody = contactBaseBody * a + bodyBand * (1 - a);
contactBaseNoise = contactBaseNoise * a + (noiseBand + 0.5 * voiceBand) * (1 - a);
}
contactBaseCount = Math.min(1000000, contactBaseCount + 1);
}
const baseBody = contactBaseCount > 10 ? contactBaseBody : bodyBand;
const baseNoise = contactBaseCount > 10 ? contactBaseNoise : (noiseBand + 0.5 * voiceBand);
const bodyExcess = Math.max(0, bodyBand - baseBody * 1.02);
const noiseMix = Math.max(1, (noiseBand + 0.5 * voiceBand + 0.3 * lowBand) - baseNoise * 0.2);
let score = (bodyExcess / noiseMix) * CONFIG.CONTACT.BODY_EXCESS_GAIN;
const ratio = bodyBand / (noiseBand + 0.5 * voiceBand + 0.3 * lowBand + 1);
const ratioScore = (ratio - 0.35) * 140;
score = Math.max(score, ratioScore);
if (voiceBand > bodyBand * 1.4) score *= 0.6;
return clamp(score, 0, 100);
}
function updateConfirmedContact(gateLevel, now) {
const norm = clamp(gateLevel / 100, 0, 1);
if (!confirmedContact) {
if (norm >= CONFIG.CONTACT.ENTER_TH) {
if (contactEnterSince === 0) contactEnterSince = now;
if ((now - contactEnterSince) >= CONFIG.CONTACT.ENTER_MS) {
confirmedContact = true;
lastConfirmedContactAt = now;
contactExitSince = 0;
}
} else {
contactEnterSince = 0;
}
} else {
lastConfirmedContactAt = now;
if (norm <= CONFIG.CONTACT.EXIT_TH) {
if (contactExitSince === 0) contactExitSince = now;
if ((now - contactExitSince) >= CONFIG.CONTACT.EXIT_MS) {
confirmedContact = false;
contactEnterSince = 0;
}
} else {
contactExitSince = 0;
}
}
}
function updateContactIndicator(rawLevel, gateLevel, now) {
currentContactRaw = rawLevel;
rawContactScore = rawLevel;
contactForGate = gateLevel;
updateConfirmedContact(gateLevel, now);
const uiTarget = confirmedContact ? gateLevel : Math.min(gateLevel, CONFIG.CONTACT.UI_WEAK_CAP);
contactSmooth += (uiTarget - contactSmooth) * CONFIG.CONTACT.SMOOTH_FACTOR;
contactLevel = contactSmooth;
let levelText, levelClass, barColor;
if (!confirmedContact || contactLevel < 30) {
levelText = 'Weak'; levelClass = 'weak'; barColor = '#f44336';
} else if (contactLevel < 60) {
levelText = 'Moderate'; levelClass = 'moderate'; barColor = '#ff9800';
} else if (contactLevel < 85) {
levelText = 'Good'; levelClass = 'good'; barColor = '#8bc34a';
} else {
levelText = 'Excellent'; levelClass = 'excellent'; barColor = '#4caf50';
}
if (dom.contactLevel) {
dom.contactLevel.textContent = levelText;
dom.contactLevel.className = `contact-level ${levelClass}`;
}
if (dom.contactBarFill) {
dom.contactBarFill.style.width = `${contactLevel}%`;
dom.contactBarFill.style.background = barColor;
}
}
function resetContactIndicator() {
contactLevel = 0;
contactSmooth = 0;
currentContactRaw = 0;
rawContactScore = 0;
contactForGate = 0;
confirmedContact = false;
contactEnterSince = 0;
contactExitSince = 0;
lastConfirmedContactAt = 0;
lfMechanical = 0;
hfAirborne = 0;
contactAirRatio = 0;
if (dom.contactLevel) {
dom.contactLevel.textContent = '--';
dom.contactLevel.className = 'contact-level';
}
if (dom.contactBarFill) {
dom.contactBarFill.style.width = '0%';
}
}
// ============================================================================
// MOTION & TILT DETECTION
// ============================================================================
function updateMotionHint() {
if (!dom.motionHint || !dom.motionHintText) return;
if (!isRunning || !isCalibrated) {
dom.motionHint.classList.remove('active');
motion.currentHint = null;
lastHintShown = null;
return;
}
let hint = null;
if (motion.isShaking) hint = 'ü§≤ Hold steady';
else if (motion.isTilted) hint = 'üìê Level phone';
const now = nowMs();
if (hint !== lastHintShown) {
if (hintChangeAt === 0 || (now - hintChangeAt) < CONFIG.UI.HINT_HYSTERESIS_MS) {
if (hintChangeAt === 0) hintChangeAt = now;
hint = lastHintShown;
} else {
lastHintShown = hint;
hintChangeAt = 0;
}
} else {
hintChangeAt = 0;
}
if (hint && hint !== motion.currentHint) {
dom.motionHintText.textContent = hint;
dom.motionHint.classList.add('active');
motion.currentHint = hint;
} else if (!hint) {
dom.motionHint.classList.remove('active');
motion.currentHint = null;
}
}
async function requestMotionPermissions() {
if (typeof DeviceMotionEvent !== 'undefined' &&
typeof DeviceMotionEvent.requestPermission === 'function') {
try { await DeviceMotionEvent.requestPermission(); }
catch (err) { console.warn('Motion permission denied:', err); }
}
if (typeof DeviceOrientationEvent !== 'undefined' &&
typeof DeviceOrientationEvent.requestPermission === 'function') {
try { await DeviceOrientationEvent.requestPermission(); }
catch (err) { console.warn('Orientation permission denied:', err); }
}
}
function addMotionListeners() {
if (typeof DeviceMotionEvent !== 'undefined') {
window.addEventListener('devicemotion', onMotion);
}
if (typeof DeviceOrientationEvent !== 'undefined') {
window.addEventListener('deviceorientation', onOrientation);
}
}
function removeMotionListeners() {
window.removeEventListener('devicemotion', onMotion);
window.removeEventListener('deviceorientation', onOrientation);
}
function onMotion(e) {
if (!isRunning) return;
const a = e.accelerationIncludingGravity || e.acceleration;
if (!a) return;
const total = Math.sqrt((a.x || 0) ** 2 + (a.y || 0) ** 2 + (a.z || 0) ** 2);
if (!Number.isFinite(total)) return;
if (motion.baseTotal === null) {
motion.baseTotal = total;
motion.smoothAccel = 0;
return;
}
if (!Number.isFinite(motion.baseTotal)) {
motion.baseTotal = total;
motion.smoothAccel = 0;
return;
}
const diff = Math.abs(total - motion.baseTotal);
if (!Number.isFinite(diff)) return;
motion.smoothAccel = motion.smoothAccel * CONFIG.MOTION.SMOOTH_ALPHA + diff * CONFIG.MOTION.SMOOTH_BETA;
motion.accelBuffer.push(diff);
while (motion.accelBuffer.length > CONFIG.MOTION.ACCEL_BUFFER_MAX) motion.accelBuffer.shift();
motion.isShaking = rms(motion.accelBuffer) > CONFIG.MOTION.SHAKE_RMS_TH;
const motionTh = (appState === 'WAITING' || appState === 'CALIBRATION') ? CONFIG.MOTION.THRESHOLD_WAIT : CONFIG.MOTION.THRESHOLD;
const moving = motion.smoothAccel > motionTh;
if (moving || motion.isShaking) {
stability.isStable = false;
stability.isSoftStable = false;
} else if (!motion.isTilted) {
stability.isStable = true;
stability.isSoftStable = true;
}
setStabilityUI();
updateMotionHint();
}
function onOrientation(e) {
if (!isRunning) return;
const b = e.beta || 0, g = e.gamma || 0;
orient.currentBeta = b;
orient.currentGamma = g;
if (orient.baseline === null) {
orient.baseline = { beta: b, gamma: g };
return;
}
const maxTilt = Math.max(Math.abs(b - orient.baseline.beta), Math.abs(g - orient.baseline.gamma));
motion.isTilted = maxTilt > CONFIG.TILT.ANGLE_MAX;
if (motion.isTilted) stability.isSoftStable = false;
setStabilityUI();
updateMotionHint();
}
function setStabilityUI() {
if (!dom.stabilityDot) return;
if (!isRunning || !isCalibrated) {
dom.stabilityDot.style.background = '#bbb';
dom.stabilityText.textContent = '--';
dom.unstableBadge.classList.remove('active');
dom.signalMeter.classList.remove('unstable');
return;
}
if (stability.isStable && stability.isSoftStable) {
dom.stabilityDot.style.background = '#4caf50';
dom.stabilityText.textContent = 'Stable';
dom.unstableBadge.classList.remove('active');
dom.signalMeter.classList.remove('unstable');
} else {
dom.stabilityDot.style.background = '#ff9800';
dom.stabilityText.textContent = 'Moving';
dom.unstableBadge.classList.add('active');
dom.signalMeter.classList.add('unstable');
}
}
// ============================================================================
// STATE MACHINE
// ============================================================================
function updateStableSince(condition, since, now) {
if (condition) return since || now;
return 0;
}
function stableFor(since, now) {
return since > 0 ? (now - since) : 0;
}
function transitionToState(nextState, reason) {
const now = nowMs();
const prevState = appState;
if (appState !== nextState) {
appState = nextState;
stateEnteredAt = now;
if (prevState === 'CALIBRATION' && nextState !== 'CALIBRATION') {
calWeightSum = 0;
calCleanFrames = 0;
calBadSince = 0;
calSoftBadSince = 0;
dom.progressFill.style.width = '0%';
dom.progressText.textContent = 'üì± Place phone on auscultation point';
}
}
if (reason) gateReason = reason;
}
function statusLine(reason) {
const c = Math.round(contactForGate);
const h = Math.round(heartEnergy);
const v = Math.round(voiceEnergy);
const hdrPct = Math.round((lastHDR || 0) * 100);
const cc = confirmedContact ? 'C+' : 'C-';
const inStateSec = Math.max(0, Math.floor((nowMs() - stateEnteredAt) / 1000));
const baseReason = reason || gateReason;
return `${appState}(${inStateSec}s) | C:${c} ${cc} H:${h} V:${v} HDR:${hdrPct}%${baseReason ? ` | ${baseReason}` : ''}`;
}
function getWaitingFailReason(contactOK, signalOK, motionOK, tiltOK, artifactGateOK, heartConsistencyOK, periodicityGateOK) {
if (!contactOK) return 'NO_CONTACT';
if (!signalOK) return 'LOW_HEART';
if (!artifactGateOK) return 'ARTIFACT';
if (!heartConsistencyOK) return 'HEART_INCONSISTENT';
if (!periodicityGateOK) return 'NO_PERIODICITY';
return 'WAITING';
}
function getPrimaryBlocker(contactOK, signalOK, motionOK, artifactGateOK) {
if (!contactOK) return 'contact';
if (!signalOK) return 'signal';
if (!artifactGateOK) return 'artifact';
return 'none';
}
function bumpWaitFail(reason) {
if (!waitFailCounts[reason] && waitFailCounts[reason] !== 0) return;
waitFailCounts[reason]++;
}
function dominantWaitFail() {
let topReason = 'WAITING';
let topCount = -1;
for (const [reason, count] of Object.entries(waitFailCounts)) {
if (count > topCount) {
topReason = reason;
topCount = count;
}
}
return topReason;
}
function resetWaitingAccumulators() {
waitingConditionsMet = 0;
calBadSince = 0;
calSoftBadSince = 0;
waitContactGoodSince = 0;
waitMotionBadSince = 0;
waitNoContactSince = 0;
contactEnterSince = 0;
contactExitSince = 0;
waitVoiceDominantFrames = 0;
waitLowHdrFrames = 0;
waitPeriodicityScore = 0;
contactBaseBody = 0;
contactBaseNoise = 0;
contactBaseCount = 0;
artifactBurstUntil = 0;
transitionFreezeUntil = 0;
lastArtifactAt = 0;
severeArtifactAt = 0;
lastLfBandEnergy = 0;
waitFailCounts = {
NO_CONTACT: 0,
LOW_HEART: 0,
MOTION: 0,
TILT: 0,
ARTIFACT: 0,
HEART_INCONSISTENT: 0,
NO_PERIODICITY: 0,
WAITING: 0
};
}
function robustBaselineStats(values) {
if (!values || !values.length) return { mean: 0, std: 1, p50: 0, p90: 0 };
const sorted = values.slice().sort((a, b) => a - b);
const n = sorted.length;
const q = (p) => sorted[Math.min(n - 1, Math.max(0, Math.floor((n - 1) * p)))];
const p10 = q(0.10);
const p90 = q(0.90);
const p50 = q(0.50);
let sum = 0, count = 0;
for (let i = 0; i < n; i++) {
const v = sorted[i];
if (v >= p10 && v <= p90) {
sum += v;
count++;
}
}
const meanVal = count > 0 ? sum / count : p50;
const deviations = sorted.map((v) => Math.abs(v - p50)).sort((a, b) => a - b);
const mad = deviations[Math.floor((deviations.length - 1) * 0.5)] || 0;
const robustStd = Math.max(1e-3, 1.4826 * mad);
return { mean: meanVal, std: robustStd, p50, p90 };
}
function checkWaitingConditions() {
const now = nowMs();
const heartMin = CONFIG.CALIBRATION.MIN_BASELINE_ENERGY * CONFIG.CALIBRATION.HEART_CONSISTENCY_FACTOR;
const signalOK = confirmedContact ? true : (heartEnergy > heartMin || !isSilent);
const motionBadNow = motion.isShaking || motion.smoothAccel > CONFIG.MOTION.THRESHOLD_WAIT;
const voiceDominantNow = voiceEnergy > (heartEnergy * 1.15);
const contactOK = confirmedContact && contactForGate >= CONFIG.CALIBRATION.CONTACT_MIN_START;
if (motionBadNow) {
if (waitMotionBadSince === 0) waitMotionBadSince = now;
} else {
waitMotionBadSince = 0;
}
const motionOK = waitMotionBadSince === 0 || (now - waitMotionBadSince) < CONFIG.MOTION.WAIT_DEBOUNCE_MS;
const tiltOK = !motion.isTilted;
const totalEnergy = heartEnergy + voiceEnergy + 0.01;
const heartDominanceRatio = heartEnergy / totalEnergy;
lastHDR = heartDominanceRatio;
const hdrOK = heartDominanceRatio > CONFIG.VOICE.HDR_MIN_WAIT_HINT;
waitVoiceDominantFrames = voiceDominantNow ? Math.min(200, waitVoiceDominantFrames + 1) : Math.max(0, waitVoiceDominantFrames - 1);
waitLowHdrFrames = !hdrOK ? Math.min(200, waitLowHdrFrames + 1) : Math.max(0, waitLowHdrFrames - 1);
const voiceGateOK = waitVoiceDominantFrames < CONFIG.CALIBRATION.VOICE_BLOCK_FRAMES;
const hdrGateOK = waitLowHdrFrames < CONFIG.CALIBRATION.HDR_BLOCK_FRAMES;
const severeArtifactGateOK = (now - severeArtifactAt) > CONFIG.ARTIFACT.CAL_BLOCK_MS;
const artifactSoftActive = now <= transitionFreezeUntil || now <= artifactBurstUntil;
const artifactGateOK = severeArtifactGateOK;
const heartConsistencyOK = confirmedContact ? true : (heartEnergy > heartMin || !isSilent);
const periodicityGateOK = waitPeriodicityScore >= CONFIG.CALIBRATION.PERIODICITY_MIN;
const allConditionsOK = contactOK && signalOK && artifactGateOK;
return { allConditionsOK, contactOK, signalOK, motionOK, tiltOK, hdrOK, voiceGateOK, hdrGateOK, artifactGateOK, artifactSoftActive, heartConsistencyOK, periodicityGateOK };
}
function updateWaitingUI(contactOK, signalOK, motionOK, tiltOK, hdrOK, voiceGateOK, hdrGateOK, artifactGateOK, artifactSoftActive, heartConsistencyOK, periodicityGateOK, stableStart) {
const checks = [
contactOK ? '‚úì' : '‚úó',
signalOK ? '‚úì' : '‚úó',
motionOK ? '‚úì' : '‚úó',
tiltOK ? '‚úì' : '‚úó',
hdrOK ? '‚úì' : '‚úó'
];
const blocker = getPrimaryBlocker(contactOK, signalOK, motionOK, artifactGateOK);
dom.progressText.textContent = 'üì± Place phone on auscultation point';
dom.progressContainer.classList.add('show');
if (stableStart > 0) {
const elapsed = nowMs() - stableStart;
const stableMs = CONFIG.CALIBRATION.WAIT_STABLE_MS;
const percent = Math.min((elapsed / stableMs) * 100, 100);
dom.progressFill.style.width = percent + '%';
dom.statusText.textContent = statusLine(`ready in ${Math.ceil((stableMs - elapsed) / 1000)}s`);
} else {
dom.progressFill.style.width = '0%';
const failReason = getWaitingFailReason(contactOK, signalOK, motionOK, tiltOK, artifactGateOK, heartConsistencyOK, periodicityGateOK);
const hdrHint = hdrOK ? 'HDR ok' : 'HDR low';
const softHint = `${motionOK ? '' : ', MOTION warn'}${voiceGateOK ? '' : ', VOICE warn'}${hdrGateOK ? '' : ', HDR warn'}${artifactSoftActive ? ', ART soft' : ''}`;
dom.statusText.textContent = `${statusLine(`${failReason}, ${hdrHint}${softHint}`)} | blocker:${blocker} | ${checks[0]}C ${checks[1]}S ${checks[2]}M ${checks[3]}T ${checks[4]}H`;
}
}
function updateWaitingState() {
const { allConditionsOK, contactOK, signalOK, motionOK, tiltOK, hdrOK, voiceGateOK, hdrGateOK, artifactGateOK, artifactSoftActive, heartConsistencyOK, periodicityGateOK } = checkWaitingConditions();
if (!contactOK) transitionToState('NO_CONTACT', 'no_contact');
else if (appState === 'NO_CONTACT') transitionToState('WAITING', 'contact_candidate');
if (waitingStartAt === 0) waitingStartAt = nowMs();
if (allConditionsOK) {
gateReason = 'wait_ready';
if (waitingConditionsMet === 0) {
waitingConditionsMet = nowMs();
} else {
const stableTime = nowMs() - waitingConditionsMet;
if (stableTime >= CONFIG.CALIBRATION.WAIT_STABLE_MS) {
transitionToState('CALIBRATION', 'contact+safe_ok');
calStartAt = nowMs();
calFrames = [];
contactCalFrames = [];
calWeightSum = 0;
calCleanFrames = 0;
calBadSince = 0;
resetWaitingAccumulators();
waitingStartAt = 0;
dom.statusText.textContent = 'üîß Calibrating...';
return;
}
}
} else {
waitingConditionsMet = 0;
const failReason = getWaitingFailReason(contactOK, signalOK, motionOK, tiltOK, artifactGateOK, heartConsistencyOK, periodicityGateOK);
gateReason = failReason.toLowerCase();
bumpWaitFail(failReason);
}
if ((nowMs() - waitingStartAt) > CONFIG.CALIBRATION.WAITING_TIMEOUT_MS) {
const topReason = dominantWaitFail();
waitingStartAt = nowMs();
resetWaitingAccumulators();
gateReason = `wait_timeout_${topReason.toLowerCase()}`;
dom.statusText.textContent = statusLine(`WAIT_TIMEOUT(${topReason}) ‚Üí retry`);
dom.progressFill.style.width = '0%';
return;
}
updateWaitingUI(contactOK, signalOK, motionOK, tiltOK, hdrOK, voiceGateOK, hdrGateOK, artifactGateOK, artifactSoftActive, heartConsistencyOK, periodicityGateOK, waitingConditionsMet);
}
function updateCalibrationState() {
const now = nowMs();
if (calStartAt && (now - calStartAt) > CONFIG.CALIBRATION.TIMEOUT_MS) {
transitionToState('WAITING', 'cal_timeout');
waitingStartAt = 0;
calFrames = [];
contactCalFrames = [];
calWeightSum = 0;
calCleanFrames = 0;
calBadSince = 0;
resetWaitingAccumulators();
calBadFrames = 0;
calStartAt = 0;
dom.statusText.textContent = '‚ö†Ô∏è Calibration timeout ‚Üí retry';
dom.progressContainer.classList.add('show');
return;
}
const { allConditionsOK, contactOK, signalOK, motionOK, tiltOK, voiceGateOK, hdrGateOK, artifactGateOK, artifactSoftActive, heartConsistencyOK, periodicityGateOK } = checkWaitingConditions();
const enforcePeriodicityInCal = calFrames.length >= 12;
const hardConditionsOK = allConditionsOK && (!enforcePeriodicityInCal || periodicityGateOK);
if (!hardConditionsOK) {
if ((now - calStartAt) < CONFIG.CALIBRATION.MIN_HOLD_MS) {
gateReason = 'cal_hold';
dom.statusText.textContent = statusLine('cal hold');
return;
}
if (calBadSince === 0) calBadSince = now;
const badMs = now - calBadSince;
const failedCond = !contactOK ? 'Contact' : !signalOK ? 'Signal' : !motionOK ? 'Motion' : !tiltOK ? 'Tilt' : !artifactGateOK ? 'Artifact' : !heartConsistencyOK ? 'No-heart' : (enforcePeriodicityInCal && !periodicityGateOK) ? 'Periodicity' : 'Condition';
gateReason = `cal_${failedCond.toLowerCase()}`;
const remainingMs = Math.max(0, CONFIG.CALIBRATION.BAD_DEBOUNCE_MS - badMs);
dom.statusText.textContent = statusLine(`${failedCond.toLowerCase()} unstable (${Math.ceil(remainingMs / 1000)}s)`);
if (badMs >= CONFIG.CALIBRATION.BAD_DEBOUNCE_MS) {
transitionToState('WAITING', `cal_lost_${failedCond.toLowerCase()}`);
waitingStartAt = 0;
calFrames = [];
contactCalFrames = [];
calWeightSum = 0;
calCleanFrames = 0;
calBadSince = 0;
resetWaitingAccumulators();
calBadFrames = 0;
calStartAt = 0;
dom.progressContainer.classList.add('show');
dom.statusText.textContent = statusLine(`${failedCond.toLowerCase()} lost ‚Üí restarting`);
return;
}
return;
}
calBadFrames = 0;
calBadSince = 0;
const softUnstable = !motionOK || artifactSoftActive;
if (softUnstable) {
if (calSoftBadSince === 0) calSoftBadSince = now;
const softBadMs = now - calSoftBadSince;
const softRemainingMs = Math.max(0, CONFIG.CALIBRATION.BAD_DEBOUNCE_MS - softBadMs);
gateReason = !motionOK ? 'cal_soft_motion' : 'cal_soft_artifact';
dom.statusText.textContent = statusLine(`soft unstable (${Math.ceil(softRemainingMs / 1000)}s)`);
if (softBadMs >= CONFIG.CALIBRATION.BAD_DEBOUNCE_MS) {
transitionToState('WAITING', !motionOK ? 'cal_lost_motion' : 'cal_lost_artifact_soft');
waitingStartAt = 0;
calFrames = [];
contactCalFrames = [];
calWeightSum = 0;
calCleanFrames = 0;
calBadSince = 0;
calSoftBadSince = 0;
resetWaitingAccumulators();
calBadFrames = 0;
calStartAt = 0;
dom.progressContainer.classList.add('show');
dom.statusText.textContent = statusLine(!motionOK ? 'motion unstable ‚Üí restarting' : 'artifact soft ‚Üí restarting');
return;
}
} else {
calSoftBadSince = 0;
}
const calTotalEnergy = heartEnergy + voiceEnergy + 0.01;
const calHdr = heartEnergy / calTotalEnergy;
const voiceHigh = voiceEnergy > (heartEnergy * 1.15);
const hdrBad = calHdr < CONFIG.VOICE.HDR_MIN_WAIT_HINT;
let frameWeight = 1.0;
if (voiceHigh) frameWeight *= 0.2;
if (hdrBad) frameWeight *= 0.5;
if (artifactSoftActive) frameWeight *= 0.6;
gateReason = voiceHigh || hdrBad ? 'cal_penalty' : 'cal_clean';
calWeightSum += frameWeight;
if (!voiceHigh && !hdrBad) calCleanFrames++;
if (!voiceHigh || frameWeight >= 0.5) {
calFrames.push(heartEnergy);
contactCalFrames.push(currentContactRaw);
}
const progress = (calWeightSum / CONFIG.CALIBRATION.REQUIRED_WEIGHT) * 100;
dom.progressFill.style.width = progress + '%';
dom.progressText.textContent = `Calibrating... ${Math.round(progress)}% (${calCleanFrames} clean)`;
dom.statusText.textContent = statusLine(`cal ${Math.round(progress)}%`);
if (calWeightSum >= CONFIG.CALIBRATION.REQUIRED_WEIGHT && calCleanFrames >= CONFIG.CALIBRATION.MIN_CLEAN_FRAMES) {
const stats = robustBaselineStats(calFrames);
if (stats.mean < CONFIG.CALIBRATION.MIN_BASELINE_ENERGY) {
console.warn('[CAL] baseline weak', { calMean: stats.mean, p50: stats.p50, p90: stats.p90, min: CONFIG.CALIBRATION.MIN_BASELINE_ENERGY });
transitionToState('WAITING', 'cal_baseline_weak');
waitingStartAt = 0;
calFrames = [];
contactCalFrames = [];
calWeightSum = 0;
calCleanFrames = 0;
calBadSince = 0;
resetWaitingAccumulators();
calBadFrames = 0;
calStartAt = 0;
dom.statusText.textContent = '‚ö†Ô∏è Signal too weak ‚Üí retry';
dom.progressContainer.classList.add('show');
return;
}
baseline.mean = stats.mean;
baseline.std = stats.std;
transitionToState('LIVE', 'cal_done');
isCalibrated = true;
calBadFrames = 0;
calBadSince = 0;
calStartAt = 0;
calWeightSum = 0;
calCleanFrames = 0;
dom.progressContainer.classList.remove('show');
dom.statusText.textContent = statusLine('analyzing');
dom.recalBtn.style.display = 'block';
lastGoodContactAt = nowMs();
silenceDurationMs = 0;
silenceStartAt = 0;
contactLostAt = 0;
continuousMotionStart = 0;
motionStartAt = 0;
voiceDominantFrames = 0;
lowHdrFrames = 0;
waitVoiceDominantFrames = 0;
waitLowHdrFrames = 0;
}
}
function triggerRecalibration(reason) {
transitionToState('NO_CONTACT', reason.toLowerCase());
waitingStartAt = 0;
isCalibrated = false;
calFrames = [];
contactCalFrames = [];
calWeightSum = 0;
calCleanFrames = 0;
resetWaitingAccumulators();
calBadFrames = 0;
calBadSince = 0;
calStartAt = 0;
signalStrength = 0;
heartRate = 0;
hrConfirmed = false;
rr = [];
envelope.clear();
preCalSeries.clear();
qualityHistory = [];
contactLostAt = 0;
continuousMotionStart = 0;
silenceStartAt = 0;
motionStartAt = 0;
voiceDominantFrames = 0;
lowHdrFrames = 0;
waitVoiceDominantFrames = 0;
waitLowHdrFrames = 0;
waitMotionBadSince = 0;
waitContactGoodSince = 0;
periodicityScore = 0;
waitPeriodicityScore = 0;
bestLagBpm = 0;
hrGateReason = reason.toLowerCase();
contactStableSince = 0;
motionStableSince = 0;
signalStableSince = 0;
artifactBurstUntil = 0;
lastArtifactAt = 0;
lastLfBandEnergy = 0;
contactBaseBody = 0;
contactBaseNoise = 0;
contactBaseCount = 0;
confirmedContact = false;
contactEnterSince = 0;
contactExitSince = 0;
dom.statusText.textContent = statusLine(`${reason.toLowerCase()} ‚Üí recal`);
dom.progressContainer.classList.add('show');
dom.recalBtn.style.display = 'none';
}
function updateLiveState(deltaMs) {
const now = nowMs();
if (!confirmedContact) {
if (contactLostAt === 0) contactLostAt = now;
if ((now - contactLostAt) >= CONFIG.CONTACT.LOST_DEBOUNCE_MS) {
triggerRecalibration('Contact lost');
return;
}
} else {
contactLostAt = 0;
}
if (isSilent) {
if (silenceStartAt === 0) silenceStartAt = now;
if ((now - silenceStartAt) >= CONFIG.SILENCE.DEBOUNCE_MS) silenceDurationMs += deltaMs;
if (silenceDurationMs >= CONFIG.SILENCE.DURATION_MAX_MS) {
triggerRecalibration('Silence > 3s');
return;
}
} else {
silenceDurationMs = 0;
silenceStartAt = 0;
}
if (!stability.isStable || motion.isShaking) {
if (motionStartAt === 0) motionStartAt = now;
if ((now - motionStartAt) >= CONFIG.RECALIBRATION.DEBOUNCE_MS) {
if (continuousMotionStart === 0) continuousMotionStart = now;
if ((now - continuousMotionStart) >= CONFIG.RECALIBRATION.MOTION_TIMEOUT_MS) {
triggerRecalibration('Excessive motion');
return;
}
}
} else {
continuousMotionStart = 0;
motionStartAt = 0;
}
lastGoodContactAt = now;
const artifactActive = now < artifactBurstUntil;
const frozen = updateMotionMask() || artifactActive;
if (isSilent) {
signalStrength += (0 - signalStrength) * CONFIG.QUALITY.SMOOTH_FACTOR * 2;
currentSNR = CONFIG.QUALITY.SNR_FLOOR;
updateQualityHistory(0);
dom.statusText.textContent = statusLine('silent');
return;
}
if (frozen) {
updateQualityHistory(Math.round(signalStrength));
dom.statusText.textContent = statusLine(artifactActive ? 'artifact freeze' : 'motion freeze');
return;
}
const normalized = (heartEnergy - baseline.mean) / (baseline.std + 0.01);
const rawQuality = 50 + normalized * 15;
const snrLinear = heartEnergy / (baseline.mean + 0.001);
currentSNR = clamp(10 * Math.log10(snrLinear), CONFIG.QUALITY.SNR_FLOOR, CONFIG.QUALITY.SNR_CEILING);
const snrBonus = clamp((currentSNR - 3) * 3, 0, 20);
let qualityWithSNR = rawQuality + snrBonus;
if (!confirmedContact) {
qualityWithSNR *= 0.3;
} else {
qualityWithSNR *= (0.5 + contactForGate / 200);
}
let targetQuality = clamp(qualityWithSNR, 0, 100);
const totalEnergy = heartEnergy + voiceEnergy + 0.01;
const hdr = heartEnergy / totalEnergy;
lastHDR = hdr;
if (voiceEnergy > heartEnergy) {
voiceDominantFrames = Math.min(200, voiceDominantFrames + 1);
lastVoiceAt = now;
} else {
voiceDominantFrames = Math.max(0, voiceDominantFrames - 1);
}
if (hdr < CONFIG.VOICE.HDR_MIN_LIVE) {
lowHdrFrames = Math.min(200, lowHdrFrames + 1);
} else {
lowHdrFrames = Math.max(0, lowHdrFrames - 1);
}
const voicePenalty = voiceDominantFrames >= CONFIG.QUALITY.VOICE_DOMINANT_FRAMES
? CONFIG.QUALITY.VOICE_PENALTY_MIN
: 1 - (voiceDominantFrames / CONFIG.QUALITY.VOICE_DOMINANT_FRAMES) * (1 - CONFIG.QUALITY.VOICE_PENALTY_MIN);
const hdrPenalty = lowHdrFrames >= CONFIG.QUALITY.HDR_LOW_FRAMES
? CONFIG.QUALITY.HDR_PENALTY_MIN
: 1 - (lowHdrFrames / CONFIG.QUALITY.HDR_LOW_FRAMES) * (1 - CONFIG.QUALITY.HDR_PENALTY_MIN);
targetQuality *= voicePenalty * hdrPenalty;
signalStrength += (targetQuality - signalStrength) * CONFIG.QUALITY.SMOOTH_FACTOR;
const adaptiveEnvScale = Math.max(8, baseline.mean * 2.5);
const envVal = clamp(heartEnergy / adaptiveEnvScale, 0, 1);
envelope.push(envVal);
updateQualityHistory(Math.round(signalStrength));
dom.statusText.textContent = statusLine(hrGateReason || 'analyzing');
}
// ============================================================================
// DSP PROCESSING
// ============================================================================
function processDSP() {
if (!isRunning || !analyser) return;
const now = nowMs();
const deltaMs = lastProcessTime > 0 ? (now - lastProcessTime) : CONFIG.UI.UPDATE_MS;
lastProcessTime = now;
envelopeDtEmaMs = envelopeDtEmaMs * 0.9 + deltaMs * 0.1;
if (!reusableFftData) reusableFftData = new Uint8Array(analyser.frequencyBinCount);
if (!reusableTimeDomain) reusableTimeDomain = new Float32Array(analyser.fftSize);
analyser.getByteFrequencyData(reusableFftData);
analyser.getFloatTimeDomainData(reusableTimeDomain);
lastTimeDomain = reusableTimeDomain;
let rawContact = analyzeContact(reusableFftData);
const lfBandNow = bandEnergy(reusableFftData, 20, 120);
const hfBandNow = bandEnergy(reusableFftData, 300, 2000);
lfMechanical = lfBandNow;
hfAirborne = hfBandNow;
contactAirRatio = hfBandNow / (lfBandNow + 1e-3);
let gateContact = rawContact;
const airborneLikely = contactAirRatio > CONFIG.CONTACT.AIR_RATIO_CLAMP && lfBandNow < CONFIG.CONTACT.LF_MECH_MIN;
if (airborneLikely) {
gateContact = Math.min(gateContact, CONFIG.CONTACT.AIR_CLAMP_MAX);
}
const lfDelta = Math.abs(lfBandNow - lastLfBandEnergy);
if (lfDelta > CONFIG.ARTIFACT.LF_DELTA_TH) {
lastArtifactAt = now;
contactArtifactHoldUntil = now + CONFIG.ARTIFACT.CONTACT_HOLD_MS;
}
lastLfBandEnergy = lfBandNow;
updateContactIndicator(rawContact, gateContact, now);
let sum = 0, peakAbs = 0, clipCount = 0;
for (let i = 0; i < reusableTimeDomain.length; i++) {
const v = reusableTimeDomain[i];
sum += v * v;
const av = Math.abs(v);
if (av > peakAbs) peakAbs = av;
if (av >= CONFIG.ARTIFACT.CLIP_TH) clipCount++;
}
lastSignalRMS = Math.sqrt(sum / reusableTimeDomain.length);
const hfStartBin = hzToBin(CONFIG.FREQ.HIGH_FREQ_GATE);
let hfEnergy = 0;
const hfCount = reusableFftData.length - hfStartBin;
for (let i = hfStartBin; i < reusableFftData.length; i++) hfEnergy += reusableFftData[i];
lastHfEnergy = hfCount > 0 ? (hfEnergy / hfCount / 255 * 100) : 0;
isSilent = lastSignalRMS < CONFIG.SILENCE.RMS_THRESHOLD && lastHfEnergy < CONFIG.SILENCE.HF_THRESHOLD;
const peakToRms = lastSignalRMS > 1e-6 ? peakAbs / lastSignalRMS : 0;
if (peakToRms > CONFIG.ARTIFACT.PEAK_TO_RMS_TH || clipCount > CONFIG.ARTIFACT.CLIP_COUNT_TH) {
artifactBurstUntil = now + CONFIG.ARTIFACT.FREEZE_MS;
lastArtifactAt = now;
transitionFreezeUntil = now + CONFIG.ARTIFACT.TRANSITION_FREEZE_MS;
}
if (peakToRms > CONFIG.ARTIFACT.PEAK_TO_RMS_SEVERE_TH || clipCount > CONFIG.ARTIFACT.CLIP_COUNT_SEVERE_TH) {
severeArtifactAt = now;
}
const cleanSpectrum = subtractNoise(reusableFftData);
const loIdx = hzToBin(CONFIG.FREQ.HEART_LOW);
const hiIdx = hzToBin(CONFIG.FREQ.HEART_HIGH);
let heartEnergyLocal = 0, weightSum = 0;
for (let i = loIdx; i <= hiIdx && i < cleanSpectrum.length; i++) {
const hz = cachedBinHz ? cachedBinHz[i] : (i * sampleRate / CONFIG.DSP.FFT_SIZE);
const boost = memsBoost(hz);
heartEnergyLocal += cleanSpectrum[i] * boost;
weightSum += boost;
}
heartEnergy = weightSum > 0 ? (heartEnergyLocal / weightSum * 100) : 0;
const voiceLoIdx = hzToBin(CONFIG.FREQ.VOICE_LOW);
const voiceHiIdx = hzToBin(CONFIG.FREQ.VOICE_HIGH);
let voiceEnergyLocal = 0;
const voiceBins = Math.max(1, voiceHiIdx - voiceLoIdx + 1);
for (let i = voiceLoIdx; i <= voiceHiIdx && i < cleanSpectrum.length; i++) voiceEnergyLocal += cleanSpectrum[i];
voiceEnergy = voiceBins > 0 ? (voiceEnergyLocal / voiceBins * 100) : 0;
const preCalScale = Math.max(8, baseline.mean * 2.5, CONFIG.CALIBRATION.MIN_BASELINE_ENERGY * 2);
preCalSeries.push(clamp(heartEnergy / preCalScale, 0, 1));
if (preCalSeries.length >= 40) {
const preWin = Math.min(80, preCalSeries.length);
const env = preCalSeries.last(preWin);
const fps = 1000 / Math.max(1, envelopeDtEmaMs);
const minLag = Math.max(1, Math.floor((60 / CONFIG.HR.MAX) * fps));
const maxLag = Math.max(minLag + 1, Math.ceil((60 / CONFIG.HR.MIN) * fps));
let bestCorr = -1;
for (let lag = minLag; lag <= maxLag; lag++) {
const corr = computeAutocorrelation(env, lag);
if (corr > bestCorr) bestCorr = corr;
}
waitPeriodicityScore = Math.max(0, bestCorr);
} else {
waitPeriodicityScore = 0;
}
if (appState === 'WAITING' || appState === 'NO_CONTACT') {
const falseGreen = (waitPeriodicityScore < 0.08) && (isSilent || voiceEnergy > heartEnergy * 1.2);
const handheldLikely =
!confirmedContact &&
waitPeriodicityScore < 0.10 &&
heartEnergy < CONFIG.CALIBRATION.HEART_START_MIN * 1.1 &&
(motion.isShaking || motion.smoothAccel > CONFIG.MOTION.THRESHOLD_WAIT * 0.7);
if (falseGreen || handheldLikely) {
gateContact = Math.min(gateContact, CONFIG.CONTACT.FALSE_GREEN_MAX);
updateContactIndicator(rawContact, gateContact, now);
}
}
const voiceHint = (now - lastVoiceAt) < CONFIG.VOICE.HOLD_MS || voiceEnergy > heartEnergy;
const periodicityHint = periodicityScore > CONFIG.HR.AUTOCORR_MIN;
const trueSilence = isSilent && peakToRms < CONFIG.SILENCE.PEAK_TO_RMS_MAX;
const weakContact = contactForGate < CONFIG.CALIBRATION.CONTACT_MIN;
const noContactNow = (appState === 'WAITING' || appState === 'NO_CONTACT') && !confirmedContact && contactForGate <= CONFIG.CALIBRATION.NO_CONTACT_LEARN_MAX;
if (noContactNow) {
if (waitNoContactSince === 0) waitNoContactSince = now;
} else {
waitNoContactSince = 0;
}
const noContactStable = waitNoContactSince > 0 && (now - waitNoContactSince) >= CONFIG.CALIBRATION.NO_CONTACT_LEARN_MS;
const motionBadForLearn = motion.isShaking || motion.smoothAccel > CONFIG.MOTION.THRESHOLD_WAIT;
const lowHeartForLearn = heartEnergy < Math.max(0.8, CONFIG.CALIBRATION.HEART_START_MIN * 0.5);
const noRecentContact = (now - lastConfirmedContactAt) >= CONFIG.CALIBRATION.NO_CONTACT_RECENT_MS;
const shouldLearnNoise = trueSilence &&
noContactStable &&
weakContact &&
!periodicityHint &&
!voiceHint &&
!motionBadForLearn &&
lowHeartForLearn &&
stability.isStable &&
noRecentContact &&
(appState === 'NO_CONTACT');
if (shouldLearnNoise) {
updateNoiseFloor(reusableFftData, CONFIG.NOISE.ALPHA);
}
if (appState === 'WAITING' || appState === 'NO_CONTACT') {
updateWaitingState();
} else if (appState === 'CALIBRATION') {
updateCalibrationState();
} else if (appState === 'LIVE') {
updateLiveState(deltaMs);
}
if ((now - lastDiagLogAt) >= 1000) {
lastDiagLogAt = now;
console.log('[DSP]', {
state: appState,
timeInStateMs: Math.round(now - stateEnteredAt),
gateReason,
rawContact: Number(rawContact.toFixed(1)),
contactForGate: Number(contactForGate.toFixed(1)),
contactLevel: Number(contactLevel.toFixed(1)),
confirmedContact,
airRatio: Number(contactAirRatio.toFixed(2)),
waitPeriodicityScore: Number(waitPeriodicityScore.toFixed(3)),
heartEnergy: Number(heartEnergy.toFixed(2)),
voiceEnergy: Number(voiceEnergy.toFixed(2)),
isSilent,
hrGateReason
});
}
}
// ============================================================================
// UI UPDATE
// ============================================================================
function updateUI() {
const now = nowMs();
if (now - lastUIUpdate < CONFIG.UI.UPDATE_MS) return;
lastUIUpdate = now;
const voiceDetected = (now - lastVoiceAt) < CONFIG.VOICE.HOLD_MS;
dom.voiceBadge.classList.toggle('active', voiceDetected);
dom.weakBadge.classList.toggle('active', signalStrength < CONFIG.QUALITY.WEAK_THRESHOLD);
updateNeedleAndPercent();
detectHR();
if (now - lastTrendDraw > CONFIG.UI.TREND_DRAW_INTERVAL_MS) {
drawTrendGraph();
lastTrendDraw = now;
}
if (currentMode === 'visual') {
drawWaveformAndEnvelope();
drawSpectrogram(reusableFftData);
}
if (currentMode === 'ring') {
updateRingVisualization();
}
}
function onWorkletMessage(e) {
processDSP();
updateUI();
}
function setMode(mode) {
currentMode = mode;
dom.tabPosition.classList.toggle('active', mode === 'position');
dom.tabRing.classList.toggle('active', mode === 'ring');
dom.tabVisual.classList.toggle('active', mode === 'visual');
dom.positionMode.classList.toggle('active', mode === 'position');
dom.ringMode.classList.toggle('active', mode === 'ring');
dom.visualMode.classList.toggle('active', mode === 'visual');
if (mode === 'ring') updateRingVisualization();
if (mode === 'visual') resizeCanvases();
}
function updateGuide() {
if (!isRunning) {
dom.guideText.textContent = 'Press START to begin';
dom.guideText.style.color = '#fff';
dom.guideHint.textContent = 'Move device slowly to find strongest signal';
return;
}
if (!isCalibrated) {
if (appState === 'WAITING' || appState === 'NO_CONTACT') {
dom.guideText.textContent = '‚è≥ Waiting for stable body contact...';
dom.guideText.style.color = '#ffb300';
dom.guideHint.textContent = 'Press phone firmly and keep still';
} else {
dom.guideText.textContent = 'üîß Calibrating...';
dom.guideText.style.color = '#ffc107';
dom.guideHint.textContent = 'Hold position 1-2 seconds';
}
return;
}
const score = Math.round(signalStrength);
if (score >= 70) {
dom.guideText.textContent = 'üü¢ Excellent position!';
dom.guideText.style.color = '#4caf50';
dom.guideHint.textContent = 'Hold steady';
} else if (score >= 50) {
dom.guideText.textContent = 'üü° Good signal';
dom.guideText.style.color = '#8bc34a';
dom.guideHint.textContent = 'Try fine adjustments';
} else if (score >= 30) {
dom.guideText.textContent = 'üü† Moderate signal';
dom.guideText.style.color = '#ffc107';
dom.guideHint.textContent = 'Move closer or adjust angle';
} else {
dom.guideText.textContent = 'üî¥ Weak signal';
dom.guideText.style.color = '#f44336';
dom.guideHint.textContent = 'Reposition device';
}
}
function updateComparisonBars() {
if (!bestByPointDirty) return;
bestByPointDirty = false;
const barMap = {
aortic: dom.aorticBar, pulmonary: dom.pulmonaryBar,
tricuspid: dom.tricuspidBar, mitral: dom.mitralBar, erb: dom.erbBar
};
POINT_ORDER.forEach(point => {
const score = (typeof bestByPoint[point] === 'number') ? bestByPoint[point] : 0;
const el = barMap[point];
if (el) {
el.style.width = clamp(score, 0, 100) + '%';
el.style.background = qualityColor(score);
el.innerHTML = score > 0 ? `<span class="comp-value">${Math.round(score)}%</span>` : '';
}
});
}
function updateNeedleAndPercent() {
const score = Math.round(clamp(signalStrength, 0, 100));
const col = qualityColor(score);
dom.signalPercent.textContent = isCalibrated ? score : '--';
dom.signalPercent.style.color = col;
dom.signalPercent.style.textShadow = `0 0 30px ${col}`;
dom.snrDisplay.textContent = isCalibrated ? `SNR ${currentSNR.toFixed(1)} dB` : 'SNR -- dB';
const targetAngle = -135 + (score / 100) * 225;
currentNeedleAngle += (targetAngle - currentNeedleAngle) * CONFIG.UI.NEEDLE_SMOOTH;
dom.meterNeedle.style.transform = `translateX(-50%) rotate(${currentNeedleAngle}deg)`;
const voiceDetected = (nowMs() - lastVoiceAt) < CONFIG.VOICE.HOLD_MS;
if (isCalibrated && !voiceDetected && stability.isSoftStable && currentMode === 'position') {
if (score > bestSession.score) {
bestSession.score = score;
bestSession.point = POINTS[currentPoint].name;
}
const prev = (typeof bestByPoint[currentPoint] === 'number') ? bestByPoint[currentPoint] : 0;
if (score > prev) {
bestByPoint[currentPoint] = score;
bestByPointDirty = true;
}
}
dom.bestSession.textContent = bestSession.score ? (bestSession.score + '%') : '--';
dom.bestPoint.textContent = bestSession.point || '--';
const pBest = (typeof bestByPoint[currentPoint] === 'number') ? bestByPoint[currentPoint] : null;
dom.currentPointBest.textContent = (pBest !== null && pBest > 0) ? (Math.round(pBest) + '%') : '--';
updateComparisonBars();
updateGuide();
}
function resizeCanvases() {
if (!dom.waveformCanvas) return;
const dpr = window.devicePixelRatio || 1;
const rect = dom.waveformCanvas.getBoundingClientRect();
dom.waveformCanvas.width = Math.floor(rect.width * dpr);
dom.waveformCanvas.height = Math.floor(rect.height * dpr);
dom.waveCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
const rect2 = dom.spectrogramCanvas.getBoundingClientRect();
dom.spectrogramCanvas.width = Math.floor(rect2.width * dpr);
dom.spectrogramCanvas.height = Math.floor(rect2.height * dpr);
dom.spectroCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
dom.canvasW = rect.width;
dom.canvasH = rect.height;
}
function drawWaveformAndEnvelope() {
const ctx = dom.waveCtx, w = dom.canvasW, h = dom.canvasH;
ctx.fillStyle = '#0a1929';
ctx.fillRect(0, 0, w, h);
if (!lastTimeDomain || !lastTimeDomain.length) return;
ctx.strokeStyle = '#2196f3';
ctx.lineWidth = 1;
ctx.beginPath();
const step = Math.ceil(lastTimeDomain.length / w);
for (let x = 0; x < w; x++) {
const idx = Math.min(x * step, lastTimeDomain.length - 1);
const y = h / 2 - lastTimeDomain[idx] * h * 0.4;
if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
}
ctx.stroke();
if (envelope.length > 1) {
ctx.strokeStyle = '#f44336';
ctx.lineWidth = 2;
ctx.beginPath();
const envLen = envelope.length;
const envStep = w / (envLen - 1);
for (let i = 0; i < envLen; i++) {
const x = i * envStep;
const y = h - envelope.at(i) * h * 3;
if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
}
ctx.stroke();
}
}
function drawSpectrogram(fftData) {
if (!fftData) return;
const ctx = dom.spectroCtx, w = dom.canvasW, h = dom.canvasH;
const imgData = ctx.getImageData(1, 0, w - 1, h);
ctx.putImageData(imgData, 0, 0);
const barH = h / 64;
for (let i = 0; i < 64; i++) {
const idx = Math.floor(i * fftData.length / 64);
const val = fftData[idx] / 255;
ctx.fillStyle = `rgb(${Math.floor(val * 255)},${Math.floor(val * 128)},50)`;
ctx.fillRect(w - 1, h - (i + 1) * barH, 1, barH);
}
}
function detectHR() {
const now = nowMs();
const setHrOff = (reason) => {
hrGateReason = reason;
hrConfirmed = false;
dom.hrValue.textContent = '--';
dom.phaseLabel.textContent = 'Phase: --';
dom.phaseLabel.style.color = '#4caf50';
dom.s1Value.textContent = '--';
dom.s2Value.textContent = '--';
dom.snrMetric.textContent = isCalibrated ? currentSNR.toFixed(1) + ' dB' : '--';
dom.murmurValue.textContent = 'N/A';
};
if (appState !== 'LIVE' || !isCalibrated || envelope.length < 20) {
setHrOff('warming');
return;
}
const artifactActive = now < artifactBurstUntil;
const contactOK = confirmedContact;
const motionOK = stability.isStable && !motion.isShaking && !motion.isTilted;
const signalOK = !isSilent && heartEnergy >= CONFIG.CALIBRATION.MIN_BASELINE_ENERGY;
contactStableSince = updateStableSince(contactOK, contactStableSince, now);
motionStableSince = updateStableSince(motionOK, motionStableSince, now);
signalStableSince = updateStableSince(signalOK, signalStableSince, now);
const hrGate = stableFor(contactStableSince, now) >= CONFIG.HR.GATE_CONTACT_MS &&
stableFor(motionStableSince, now) >= CONFIG.HR.GATE_MOTION_MS &&
stableFor(signalStableSince, now) >= CONFIG.HR.GATE_SIGNAL_MS &&
!artifactActive;
if (!hrGate) {
if (artifactActive) setHrOff('artifact');
else if (!contactOK) setHrOff('contact');
else if (!motionOK) setHrOff('motion');
else if (!signalOK) setHrOff('signal');
else setHrOff('stabilizing');
periodicityScore = 0;
bestLagBpm = 0;
return;
}
const win = Math.min(CONFIG.HR.PERIODICITY_WINDOW_SAMPLES, envelope.length);
const env = envelope.last(win);
const fps = 1000 / Math.max(envelopeDtEmaMs, 1);
const minLag = Math.max(1, Math.floor((60 / CONFIG.HR.MAX) * fps));
const maxLag = Math.max(minLag + 1, Math.ceil((60 / CONFIG.HR.MIN) * fps));
let bestLag = minLag;
let bestCorr = -1;
for (let lag = minLag; lag <= maxLag; lag++) {
const corr = computeAutocorrelation(env, lag);
if (corr > bestCorr) {
bestCorr = corr;
bestLag = lag;
}
}
periodicityScore = Math.max(0, bestCorr);
bestLagBpm = clamp(Math.round((60 * fps) / Math.max(1, bestLag)), CONFIG.HR.MIN, CONFIG.HR.MAX);
if (periodicityScore < CONFIG.HR.AUTOCORR_MIN) {
setHrOff('periodicity-low');
return;
}
const newHR = bestLagBpm;
if (heartRate > 0 && hrConfirmed) {
const jumpRatio = Math.abs(newHR - heartRate) / heartRate;
if (jumpRatio > CONFIG.HR.MAX_JUMP_RATIO) {
setHrOff('hr-jump');
return;
}
heartRate = Math.round(heartRate * 0.75 + newHR * 0.25);
} else {
heartRate = newHR;
}
hrConfirmed = true;
hrGateReason = 'ok';
if (lastBeatMs === 0) lastBeatMs = now;
const beatMs = 60000 / Math.max(1, heartRate);
const elapsed = now - lastBeatMs;
beatPhase = (elapsed % beatMs) / beatMs;
if (elapsed >= beatMs) lastBeatMs = now;
dom.hrValue.textContent = heartRate;
if (beatPhase < CONFIG.HR.SYSTOLE_FRACTION) {
dom.phaseLabel.textContent = 'Phase: Systole';
dom.phaseLabel.style.color = '#ff5252';
} else {
dom.phaseLabel.textContent = 'Phase: Diastole';
dom.phaseLabel.style.color = '#4caf50';
}
dom.s1Value.textContent = Math.round(signalStrength * 0.8);
dom.s2Value.textContent = Math.round(signalStrength * 0.6);
dom.snrMetric.textContent = currentSNR.toFixed(1) + ' dB';
dom.murmurValue.textContent = periodicityScore >= (CONFIG.HR.AUTOCORR_MIN + 0.15) ? 'Low' : 'Possible';
}
const workletCode = `
class SampleProcessor extends AudioWorkletProcessor {
constructor() {
super();
this.buffer = new Float32Array(2048);
this.writePos = 0;
}
process(inputs) {
const input = inputs[0];
if (input && input[0]) {
const data = input[0];
for (let i = 0; i < data.length; i++) {
this.buffer[this.writePos++] = data[i];
if (this.writePos >= 2048) {
this.port.postMessage({ tick: 1 });
this.writePos = 0;
}
}
}
return true;
}
}
registerProcessor('sample-processor', SampleProcessor);
`;
function updateMotionMask() {
const now = nowMs();
if (!stability.isStable || motion.isShaking || motion.isTilted) {
lastMotionAt = now;
motionFrozen = true;
} else if (motionFrozen && (now - lastMotionAt) > CONFIG.MOTION.FREEZE_MS) {
motionFrozen = false;
}
return motionFrozen;
}
function computeAutocorrelation(arr, lag) {
if (arr.length < lag * 2) return 0;
const n = arr.length - lag;
const m = mean(arr);
let num = 0, den = 0;
for (let i = 0; i < n; i++) {
const d = arr[i] - m;
num += d * (arr[i + lag] - m);
den += d * d;
}
return den > 0 ? num / den : 0;
}
// ============================================================================
// START / STOP / RESET / RECALIBRATE
// ============================================================================
async function startAnalysis() {
try {
await requestMotionPermissions();
stream = await navigator.mediaDevices.getUserMedia({
audio: {
echoCancellation: false,
noiseSuppression: false,
autoGainControl: false,
sampleRate: { ideal: CONFIG.DSP.SAMPLE_RATE_IDEAL }
}
});
audioCtx = new (window.AudioContext || window.webkitAudioContext)({
sampleRate: CONFIG.DSP.SAMPLE_RATE_IDEAL
});
if (audioCtx.state === 'suspended') await audioCtx.resume();
sampleRate = audioCtx.sampleRate;
buildBinHzCache();
mic = audioCtx.createMediaStreamSource(stream);
analyser = audioCtx.createAnalyser();
analyser.fftSize = CONFIG.DSP.FFT_SIZE;
analyser.smoothingTimeConstant = 0.3;
zeroGain = audioCtx.createGain();
zeroGain.gain.value = 0;
if (!audioCtx.audioWorklet) {
alert('–ë—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç AudioWorklet. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome 66+ –∏–ª–∏ Safari 14.1+');
stopAnalysis();
return;
}
const blob = new Blob([workletCode], { type: 'application/javascript' });
const url = URL.createObjectURL(blob);
await audioCtx.audioWorklet.addModule(url);
URL.revokeObjectURL(url);
workletNode = new AudioWorkletNode(audioCtx, 'sample-processor');
workletNode.port.onmessage = onWorkletMessage;
mic.connect(analyser);
mic.connect(workletNode);
workletNode.connect(zeroGain);
zeroGain.connect(audioCtx.destination);
isRunning = true;
isCalibrated = false;
transitionToState('NO_CONTACT', 'start');
waitingStartAt = 0;
calStartAt = 0;
calBadFrames = 0;
calBadSince = 0;
lastGoodContactAt = 0;
silenceDurationMs = 0;
silenceStartAt = 0;
contactLostAt = 0;
continuousMotionStart = 0;
motionStartAt = 0;
lastProcessTime = 0;
calFrames = [];
contactCalFrames = [];
calWeightSum = 0;
calCleanFrames = 0;
envelope.clear();
preCalSeries.clear();
rr = [];
heartRate = 0;
hrConfirmed = false;
lastPeakMs = 0;
lastBeatMs = 0;
beatPhase = 0;
lastVoiceAt = 0;
voiceDominantFrames = 0;
lowHdrFrames = 0;
waitVoiceDominantFrames = 0;
waitLowHdrFrames = 0;
resetWaitingAccumulators();
periodicityScore = 0;
waitPeriodicityScore = 0;
calWeightSum = 0;
calCleanFrames = 0;
bestLagBpm = 0;
hrGateReason = 'init';
gateReason = 'init';
contactStableSince = 0;
motionStableSince = 0;
signalStableSince = 0;
artifactBurstUntil = 0;
contactArtifactHoldUntil = 0;
lastDiagLogAt = 0;
lastArtifactAt = 0;
lastLfBandEnergy = 0;
lastSignalRMS = 0;
lastHfEnergy = 0;
contactBaseBody = 0;
contactBaseNoise = 0;
contactBaseCount = 0;
envelopeDtEmaMs = CONFIG.UI.UPDATE_MS;
lastUIUpdate = 0;
lastTrendDraw = 0;
orient.baseline = null;
motion.smoothAccel = 0;
motion.baseTotal = null;
motion.accelBuffer = [];
motion.isShaking = false;
motion.isTilted = false;
motion.currentHint = null;
stability.isStable = true;
stability.isSoftStable = true;
reusableFftData = null;
reusableTimeDomain = null;
isSilent = false;
lastMotionAt = 0;
motionFrozen = false;
bestByPointDirty = false;
resetDenoiser();
resetTrendHistory();
resetContactIndicator();
setStabilityUI();
updateMotionHint();
dom.startBtn.style.display = 'none';
dom.stopBtn.style.display = 'block';
dom.recalBtn.style.display = 'none';
dom.progressContainer.classList.add('show');
dom.progressFill.style.width = '0%';
dom.progressText.textContent = 'üì± Place phone on auscultation point';
dom.statusText.textContent = '‚è≥ Waiting for contact...';
updateGuide();
addMotionListeners();
} catch (err) {
alert('Microphone error: ' + (err && err.message ? err.message : err));
stopAnalysis();
}
}
function stopAnalysis() {
if (resizeTimer) { clearTimeout(resizeTimer); resizeTimer = null; }
try {
if (workletNode && workletNode.port) workletNode.port.onmessage = null;
if (workletNode) workletNode.disconnect();
if (zeroGain) zeroGain.disconnect();
if (mic) mic.disconnect();
if (analyser) analyser.disconnect();
if (audioCtx) audioCtx.close();
if (stream) stream.getTracks().forEach(t => t.stop());
} catch (e) {}
audioCtx = mic = analyser = stream = workletNode = zeroGain = null;
isRunning = false;
isCalibrated = false;
transitionToState('NO_CONTACT', 'stopped');
waitingStartAt = 0;
calStartAt = 0;
calBadFrames = 0;
calBadSince = 0;
lastGoodContactAt = 0;
silenceDurationMs = 0;
silenceStartAt = 0;
contactLostAt = 0;
continuousMotionStart = 0;
motionStartAt = 0;
periodicityScore = 0;
waitPeriodicityScore = 0;
calWeightSum = 0;
calCleanFrames = 0;
calBadFrames = 0;
calBadSince = 0;
bestLagBpm = 0;
hrGateReason = 'stopped';
gateReason = 'stopped';
contactStableSince = 0;
motionStableSince = 0;
signalStableSince = 0;
resetWaitingAccumulators();
artifactBurstUntil = 0;
contactArtifactHoldUntil = 0;
lastDiagLogAt = 0;
lastArtifactAt = 0;
lastLfBandEnergy = 0;
lastSignalRMS = 0;
lastHfEnergy = 0;
contactBaseBody = 0;
contactBaseNoise = 0;
contactBaseCount = 0;
envelopeDtEmaMs = CONFIG.UI.UPDATE_MS;
preCalSeries.clear();
lastProcessTime = 0;
removeMotionListeners();
dom.startBtn.style.display = 'block';
dom.stopBtn.style.display = 'none';
dom.recalBtn.style.display = 'none';
dom.progressContainer.classList.remove('show');
dom.statusText.textContent = '‚ö™ Stopped';
dom.signalPercent.textContent = '--';
dom.snrDisplay.textContent = 'SNR -- dB';
dom.hrValue.textContent = '--';
dom.voiceBadge.classList.remove('active');
dom.weakBadge.classList.remove('active');
dom.unstableBadge.classList.remove('active');
resetContactIndicator();
updateMotionHint();
updateGuide();
}
function resetAll() {
stopAnalysis();
bestSession = { score: 0, point: '' };
bestByPoint = {};
bestByPointDirty = true;
signalStrength = 0;
currentSNR = 0;
currentNeedleAngle = -135;
envelope.clear();
rr = [];
heartRate = 0;
hrConfirmed = false;
periodicityScore = 0;
waitPeriodicityScore = 0;
calWeightSum = 0;
calCleanFrames = 0;
bestLagBpm = 0;
hrGateReason = 'reset';
gateReason = 'reset';
contactStableSince = 0;
motionStableSince = 0;
signalStableSince = 0;
artifactBurstUntil = 0;
contactArtifactHoldUntil = 0;
lastDiagLogAt = 0;
lastArtifactAt = 0;
lastLfBandEnergy = 0;
contactBaseBody = 0;
contactBaseNoise = 0;
contactBaseCount = 0;
waitMotionBadSince = 0;
waitContactGoodSince = 0;
motion.baseTotal = null;
motion.accelBuffer = [];
motion.isShaking = false;
motion.isTilted = false;
motion.currentHint = null;
orient.baseline = null;
resetDenoiser();
preCalSeries.clear();
resetTrendHistory();
resetContactIndicator();
dom.bestSession.textContent = '--';
dom.bestPoint.textContent = '--';
dom.currentPointBest.textContent = '--';
['aorticBar', 'pulmonaryBar', 'tricuspidBar', 'mitralBar', 'erbBar'].forEach(id => {
dom[id].style.width = '0%';
dom[id].innerHTML = '';
});
if (dom.waveCtx) {
dom.waveCtx.fillStyle = '#0a1929';
dom.waveCtx.fillRect(0, 0, dom.canvasW || 300, dom.canvasH || 180);
}
if (dom.spectroCtx) {
dom.spectroCtx.clearRect(0, 0, dom.canvasW || 300, dom.canvasH || 180);
}
updateGuide();
updateMotionHint();
updateRingVisualization();
}
function recalibrate() {
if (!isRunning) return;
triggerRecalibration('Manual recalibration');
motion.baseTotal = null;
motion.accelBuffer = [];
motion.isShaking = false;
motion.isTilted = false;
orient.baseline = null;
hrGateReason = 'manual recal';
contactArtifactHoldUntil = 0;
lastDiagLogAt = 0;
waitMotionBadSince = 0;
waitContactGoodSince = 0;
resetDenoiser();
resetTrendHistory();
resetContactIndicator();
dom.voiceBadge.classList.remove('active');
dom.weakBadge.classList.remove('active');
updateMotionHint();
updateGuide();
}
function onPointChange() {
currentPoint = dom.pointSelect.value;
if (dom.pointLabel) dom.pointLabel.textContent = POINTS[currentPoint].name;
if (dom.pointLabelTop) dom.pointLabelTop.textContent = POINTS[currentPoint].name;
dom.currentPointLabel.textContent = POINTS[currentPoint].name.split(' ')[0];
const pBest = (typeof bestByPoint[currentPoint] === 'number') ? bestByPoint[currentPoint] : null;
dom.currentPointBest.textContent = (pBest !== null && pBest > 0) ? (Math.round(pBest) + '%') : '--';
}
function exportJSON() {
const data = {
version: 'v7.0.48',
timestamp: new Date().toISOString(),
appState,
timeInStateMs: Math.round(nowMs() - stateEnteredAt),
gateReason,
point: currentPoint,
mode: currentMode,
isRunning,
isCalibrated,
signalStrength: Math.round(signalStrength),
snrDb: isFinite(currentSNR) ? Number(currentSNR.toFixed(2)) : null,
heartRate: (isRunning && hrConfirmed) ? heartRate : null,
periodicityScore: Number(periodicityScore.toFixed(3)),
bestLagBpm: bestLagBpm || null,
hrGateReason,
contactLevel: Math.round(contactLevel),
contactForGate: Math.round(contactForGate),
rawContactScore: Math.round(rawContactScore),
confirmedContact,
contactAirRatio: Number(contactAirRatio.toFixed(2)),
stability: {
isStable: stability.isStable,
isSoftStable: stability.isSoftStable,
motionSmoothAccel: Number(motion.smoothAccel.toFixed(4))
},
motionTypes: {
isShaking: motion.isShaking,
isTilted: motion.isTilted,
currentHint: motion.currentHint
},
trendHistory: {
direction: trendDirection,
historySize: qualityHistory.length,
recentValues: qualityHistory.slice(-10)
},
bestSession,
bestByPoint
};
const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'auscultation_v7_0_48.json';
a.click();
setTimeout(() => URL.revokeObjectURL(url), 1000);
}
// ============================================================================
// TREND & RING VISUALIZATION (–∫–æ–ø–∏—Ä—É–µ—Ç—Å—è –∏–∑ 7.0.3)
// ============================================================================
function initTrendCanvas() {
const canvas = document.getElementById('trendCanvas');
if (!canvas) return;
const w = CONFIG.TREND.CANVAS_WIDTH, h = CONFIG.TREND.CANVAS_HEIGHT;
const dpr = window.devicePixelRatio || 1;
canvas.width = w * dpr;
canvas.height = h * dpr;
canvas.style.width = w + 'px';
canvas.style.height = h + 'px';
const ctx = canvas.getContext('2d');
ctx.scale(dpr, dpr);
dom.trendCanvas = canvas;
dom.trendCtx = ctx;
dom.trendW = w;
dom.trendH = h;
clearTrendCanvas();
}
function clearTrendCanvas() {
if (!dom.trendCtx) return;
const ctx = dom.trendCtx;
const w = dom.trendW || CONFIG.TREND.CANVAS_WIDTH;
const h = dom.trendH || CONFIG.TREND.CANVAS_HEIGHT;
ctx.fillStyle = 'rgba(0,0,0,0.4)';
ctx.fillRect(0, 0, w, h);
ctx.strokeStyle = 'rgba(255,255,255,0.1)';
ctx.lineWidth = 1;
[25, 50, 75].forEach(pct => {
const y = h - (pct / 100) * h;
ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
});
}
function updateQualityHistory(score) {
qualityHistory.push(score);
if (qualityHistory.length > CONFIG.TREND.HISTORY_SIZE) qualityHistory.shift();
}
function analyzeTrend() {
if (qualityHistory.length < CONFIG.TREND.ANALYSIS_WINDOW) return 'stable';
const recent = qualityHistory.slice(-CONFIG.TREND.ANALYSIS_WINDOW);
const n = recent.length;
let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
for (let i = 0; i < n; i++) {
sumX += i; sumY += recent[i]; sumXY += i * recent[i]; sumX2 += i * i;
}
const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
if (slope > CONFIG.TREND.SLOPE_THRESHOLD) return 'improving';
if (slope < -CONFIG.TREND.SLOPE_THRESHOLD) return 'declining';
return 'stable';
}
function drawTrendGraph() {
if (!dom.trendCtx) return;
const ctx = dom.trendCtx, w = dom.trendW, h = dom.trendH;
ctx.fillStyle = 'rgba(0,0,0,0.4)';
ctx.fillRect(0, 0, w, h);
ctx.strokeStyle = 'rgba(255,255,255,0.1)';
ctx.lineWidth = 1;
[25, 50, 75].forEach(pct => {
const y = h - (pct / 100) * h;
ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
});
if (qualityHistory.length < 2) return;
const trend = analyzeTrend();
trendDirection = trend;
const lineColor = trend === 'improving' ? '#4caf50' : trend === 'declining' ? '#f44336' : '#ffc107';
const pts = qualityHistory;
const totalPoints = CONFIG.TREND.HISTORY_SIZE;
const step = w / (totalPoints - 1);
const offsetX = (totalPoints - pts.length) * step;
ctx.strokeStyle = lineColor;
ctx.lineWidth = 2;
ctx.beginPath();
let firstX = 0, firstY = 0, lastX = 0, lastY = 0;
for (let i = 0; i < pts.length; i++) {
const x = offsetX + i * step;
const y = h - (clamp(pts[i], 0, 100) / 100) * (h - 4) - 2;
if (i === 0) { ctx.moveTo(x, y); firstX = x; firstY = y; }
else ctx.lineTo(x, y);
lastX = x; lastY = y;
}
ctx.stroke();
ctx.lineTo(lastX, h);
ctx.lineTo(firstX, h);
ctx.closePath();
ctx.fillStyle = lineColor === '#4caf50' ? 'rgba(76,175,80,0.2)' : lineColor === '#f44336' ? 'rgba(244,67,54,0.2)' : 'rgba(255,193,7,0.2)';
ctx.fill();
if (pts.length > 0) {
ctx.beginPath();
ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
ctx.fillStyle = lineColor;
ctx.fill();
ctx.strokeStyle = '#fff';
ctx.lineWidth = 1;
ctx.stroke();
}
updateTrendStatus(trend);
}
function updateTrendStatus(trend) {
if (!dom.trendStatus) return;
dom.trendStatus.classList.remove('improving', 'declining', 'stable');
if (trend === 'improving') {
dom.trendStatus.textContent = 'Improving ‚Üë';
dom.trendStatus.classList.add('improving');
} else if (trend === 'declining') {
dom.trendStatus.textContent = 'Declining ‚Üì';
dom.trendStatus.classList.add('declining');
} else {
dom.trendStatus.textContent = 'Stable ‚Üí';
dom.trendStatus.classList.add('stable');
}
}
function resetTrendHistory() {
qualityHistory = [];
trendDirection = 'stable';
if (dom.trendStatus) {
dom.trendStatus.textContent = '--';
dom.trendStatus.classList.remove('improving', 'declining', 'stable');
}
clearTrendCanvas();
}
function createClipPath(startAngle, endAngle) {
const cx = 50, cy = 50, r = 55, points = [`${cx}% ${cy}%`];
for (let a = startAngle; a <= endAngle; a += 5) {
const rad = (a - 90) * Math.PI / 180;
points.push(`${cx + r * Math.cos(rad)}% ${cy + r * Math.sin(rad)}%`);
}
const endRad = (endAngle - 90) * Math.PI / 180;
points.push(`${cx + r * Math.cos(endRad)}% ${cy + r * Math.sin(endRad)}%`);
return `polygon(${points.join(', ')})`;
}
function initRing() {
const container = dom.ringContainer;
if (!container) return;
container.querySelectorAll('.ring-segment, .ring-label').forEach(el => el.remove());
POINT_ORDER.forEach((point, idx) => {
const startAngle = idx * 72, endAngle = startAngle + 72;
const seg = document.createElement('div');
seg.className = 'ring-segment';
seg.id = `segment-${point}`;
seg.style.clipPath = createClipPath(startAngle, endAngle);
seg.style.background = 'rgba(100,100,100,0.3)';
container.appendChild(seg);
const label = document.createElement('div');
label.className = 'ring-label';
label.id = `label-${point}`;
const midAngle = (startAngle + endAngle) / 2;
const labelRadius = 85;
const rad = (midAngle - 90) * Math.PI / 180;
label.style.left = `${110 + labelRadius * Math.cos(rad)}px`;
label.style.top = `${110 + labelRadius * Math.sin(rad)}px`;
label.innerHTML = `${POINTS[point].name}<br>--`;
container.appendChild(label);
});
}
function updateRingVisualization() {
let maxScore = 0;
POINT_ORDER.forEach(point => {
const seg = document.getElementById(`segment-${point}`);
const label = document.getElementById(`label-${point}`);
const score = (typeof bestByPoint[point] === 'number') ? bestByPoint[point] : 0;
if (score > maxScore) maxScore = score;
const col = qualityColor(score);
if (seg) seg.style.background = col;
if (label) {
label.innerHTML = `${POINTS[point].name}<br>${Math.round(score)}%`;
label.style.color = col;
label.style.opacity = score > 0 ? 1 : 0.5;
}
});
if (dom.ringCenterValue) {
dom.ringCenterValue.textContent = maxScore > 0 ? `${Math.round(maxScore)}%` : '--';
dom.ringCenterValue.style.color = qualityColor(maxScore);
}
const ringBars = {
aortic: dom.aorticBarRing, pulmonary: dom.pulmonaryBarRing,
tricuspid: dom.tricuspidBarRing, mitral: dom.mitralBarRing, erb: dom.erbBarRing
};
POINT_ORDER.forEach(point => {
const score = (typeof bestByPoint[point] === 'number') ? bestByPoint[point] : 0;
const el = ringBars[point];
if (el) {
el.style.width = clamp(score, 0, 100) + '%';
el.style.background = qualityColor(score);
el.innerHTML = score > 0 ? `<span class="comp-value">${Math.round(score)}%</span>` : '';
}
});
}
function createVisibilityHandlers() {
document.addEventListener('visibilitychange', async () => {
if (!audioCtx) return;
if (document.visibilityState === 'visible' && audioCtx.state === 'suspended') {
try { await audioCtx.resume(); }
catch (err) { console.warn('Audio resume failed:', err); }
}
});
window.addEventListener('pagehide', () => {
if (isRunning) stopAnalysis();
});
}
// ============================================================================
// DOM INITIALIZATION
// ============================================================================
function initDOM() {
dom = {
tabPosition: document.getElementById('tabPosition'),
tabRing: document.getElementById('tabRing'),
tabVisual: document.getElementById('tabVisual'),
positionMode: document.getElementById('positionMode'),
ringMode: document.getElementById('ringMode'),
visualMode: document.getElementById('visualMode'),
pointSelect: document.getElementById('pointSelect'),
pointLabelTop: document.getElementById('pointLabelTop'),
pointLabel: document.getElementById('pointLabel'),
currentPointLabel: document.getElementById('currentPointLabel'),
statusText: document.getElementById('statusText'),
voiceBadge: document.getElementById('voiceBadge'),
weakBadge: document.getElementById('weakBadge'),
unstableBadge: document.getElementById('unstableBadge'),
stabilityDot: document.getElementById('stabilityDot'),
stabilityText: document.getElementById('stabilityText'),
progressContainer: document.getElementById('progressContainer'),
progressFill: document.getElementById('progressFill'),
progressText: document.getElementById('progressText'),
signalMeter: document.getElementById('signalMeter'),
signalPercent: document.getElementById('signalPercent'),
snrDisplay: document.getElementById('snrDisplay'),
meterNeedle: document.getElementById('meterNeedle'),
bestSession: document.getElementById('bestSession'),
bestPoint: document.getElementById('bestPoint'),
currentPointBest: document.getElementById('currentPointBest'),
guideText: document.getElementById('guideText'),
guideHint: document.getElementById('guideHint'),
motionHint: document.getElementById('motionHint'),
motionHintText: document.getElementById('motionHintText'),
contactIndicator: document.getElementById('contactIndicator'),
contactLevel: document.getElementById('contactLevel'),
contactBarFill: document.getElementById('contactBarFill'),
trendContainer: document.getElementById('trendContainer'),
trendStatus: document.getElementById('trendStatus'),
aorticBar: document.getElementById('aorticBar'),
pulmonaryBar: document.getElementById('pulmonaryBar'),
tricuspidBar: document.getElementById('tricuspidBar'),
mitralBar: document.getElementById('mitralBar'),
erbBar: document.getElementById('erbBar'),
aorticBarRing: document.getElementById('aorticBarRing'),
pulmonaryBarRing: document.getElementById('pulmonaryBarRing'),
tricuspidBarRing: document.getElementById('tricuspidBarRing'),
mitralBarRing: document.getElementById('mitralBarRing'),
erbBarRing: document.getElementById('erbBarRing'),
ringContainer: document.getElementById('ringContainer'),
ringCenterValue: document.getElementById('ringCenterValue'),
waveformCanvas: document.getElementById('waveformCanvas'),
spectrogramCanvas: document.getElementById('spectrogramCanvas'),
phaseLabel: document.getElementById('phaseLabel'),
hrValue: document.getElementById('hrValue'),
s1Value: document.getElementById('s1Value'),
s2Value: document.getElementById('s2Value'),
snrMetric: document.getElementById('snrMetric'),
murmurValue: document.getElementById('murmurValue'),
startBtn: document.getElementById('startBtn'),
stopBtn: document.getElementById('stopBtn'),
resetBtn: document.getElementById('resetBtn'),
ringBtn: document.getElementById('ringBtn'),
exportBtn: document.getElementById('exportBtn'),
recalBtn: document.getElementById('recalBtn')
};
dom.waveCtx = dom.waveformCanvas.getContext('2d', { alpha: false });
dom.spectroCtx = dom.spectrogramCanvas.getContext('2d');
dom.tabPosition.addEventListener('click', () => setMode('position'));
dom.tabRing.addEventListener('click', () => setMode('ring'));
dom.tabVisual.addEventListener('click', () => setMode('visual'));
dom.pointSelect.addEventListener('change', onPointChange);
dom.startBtn.addEventListener('click', startAnalysis);
dom.stopBtn.addEventListener('click', stopAnalysis);
dom.resetBtn.addEventListener('click', resetAll);
dom.ringBtn.addEventListener('click', () => setMode('ring'));
dom.exportBtn.addEventListener('click', exportJSON);
dom.recalBtn.addEventListener('click', recalibrate);
window.addEventListener('resize', () => {
if (resizeTimer) clearTimeout(resizeTimer);
resizeTimer = setTimeout(() => {
resizeCanvases();
initTrendCanvas();
}, CONFIG.UI.RESIZE_DEBOUNCE_MS);
});
window.addEventListener('beforeunload', () => {
if (isRunning) stopAnalysis();
});
document.addEventListener('touchstart', async () => {
if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
}, { once: true });
createVisibilityHandlers();
onPointChange();
resizeCanvases();
initTrendCanvas();
initRing();
setMode('position');
setStabilityUI();
updateMotionHint();
updateGuide();
console.log('%cCardiac Auscultation Trainer v7.0.48 loaded ‚Äî NO_CONTACT noise learn + soft motion CAL', 'color: #2e7d32; font-weight: bold; background: rgba(76,175,80,0.1); padding: 8px; border-radius: 4px;');
}
window.addEventListener('load', initDOM);
</script>
</body>
</html>
